__text_start:
__start:
    0213 E5CF      LDI	R28,0x5F
    0214 E0D4      LDI	R29,4
    0215 BFCD      OUT	0x3D,R28
    0216 BFDE      OUT	0x3E,R29
    0217 52C0      SUBI	R28,0x20
    0218 40D0      SBCI	R29,0
    0219 EA0A      LDI	R16,0xAA
    021A 8308      STD	Y+0,R16
    021B 2400      CLR	R0
    021C E7E2      LDI	R30,0x72
    021D E0F0      LDI	R31,0
    021E E012      LDI	R17,2
    021F 37E3      CPI	R30,0x73
    0220 07F1      CPC	R31,R17
    0221 F011      BEQ	0x0224
    0222 9201      ST	R0,Z+
    0223 CFFB      RJMP	0x021F
    0224 8300      STD	Z+0,R16
    0225 E1E4      LDI	R30,0x14
    0226 E0F4      LDI	R31,4
    0227 E6A0      LDI	R26,0x60
    0228 E0B0      LDI	R27,0
    0229 E014      LDI	R17,4
    022A 32E6      CPI	R30,0x26
    022B 07F1      CPC	R31,R17
    022C F021      BEQ	0x0231
    022D 95C8      LPM
    022E 9631      ADIW	R30,1
    022F 920D      ST	R0,X+
    0230 CFF9      RJMP	0x022A
    0231 940E084D  CALL	_main
_exit:
    0233 CFFF      RJMP	_exit
_glcd_line:
  diff                 --> Y+1
  addy                 --> R20
  addx                 --> Y+3
  dx                   --> R10
  dy                   --> R12
  i                    --> R14
  P                    --> R22
  color                --> Y+22
  y2                   --> Y+20
  x2                   --> Y+18
  y1                   --> Y+16
  x1                   --> Y+14
    0234 940E08D8  CALL	push_arg4
    0236 940E094B  CALL	push_gset5
    0238 9724      SBIW	R28,4
FILE: E:\avr\iccavrproject\mzl0512864\myGRAPHICS.C
(0001) /////////////////////////////////////////////////////////////////////////
(0002) ////                          graphics.c                             ////
(0003) ////                                                                 ////
(0004) ////   This file contains functions to draw lines, rectangles, bars, ////
(0005) ////   circles and text to a display. A function which draws a       ////
(0006) ////   single pixel must be defined before calling the functions in  ////
(0007) ////   this file. Call it glcd_pixel(x, y, color) where x is the     ////
(0008) ////   horizontal coordinate, y is the vertical coordinate, and      ////
(0009) ////   color is 1 bit to turn the pixel on or off.                   ////
(0010) ////                                                                 ////
(0011) ////   * Note: (0, 0) is treated as the upper left corner            ////
(0012) ////                                                                 ////
(0013) /////////////////////////////////////////////////////////////////////////
(0014) ////                                                                 ////
(0015) ////  glcd_line(x1, y1, x2, y2, color)                               ////
(0016) ////     * Draws a line from the first point to the second point     ////
(0017) ////       with the given color                                      ////
(0018) ////       - color can be ON or OFF                                  ////
(0019) ////                                                                 ////
(0020) ////  glcd_rect(x1, y1, x2, y2, fill, color)                         ////
(0021) ////     * Draws a rectangle with one corner at point (x1,y1) and    ////
(0022) ////       the other corner at point (x2,y2)                         ////
(0023) ////       - fill can be YES or NO                                   ////
(0024) ////       - color can be ON or OFF                                  ////
(0025) ////                                                                 ////
(0026) ////  glcd_bar(x1, y1, x2, y2, width, color)                         ////
(0027) ////     * Draws a bar (wide line) from the first point to the       ////
(0028) ////       second point                                              ////
(0029) ////       - width is the number of pixels wide                      ////
(0030) ////       - color is ON or OFF                                      ////
(0031) ////                                                                 ////
(0032) ////  glcd_circle(x, y, radius, fill, color)                         ////
(0033) ////     * Draws a circle with center at (x,y)                       ////
(0034) ////       - fill can be YES or NO                                   ////
(0035) ////       - color can be ON or OFF                                  ////
(0036) ////                                                                 ////
(0037) ////  glcd_text57(x, y, textptr, size, color)                        ////
(0038) ////     * Write the null terminated text pointed to by textptr with ////
(0039) ////       the upper left coordinate of the first character at (x,y) ////
(0040) ////       Characters are 5 pixels wide and 7 pixels tall            ////
(0041) ////       - size is an integer that scales the size of the text     ////
(0042) ////       - color is ON or OFF                                      ////
(0043) ////     * Note - This function wraps characters to the next line    ////
(0044) ////              use #define GLCD_WIDTH to specify a display width  ////
(0045) ////                                                                 ////
(0046) /////////////////////////////////////////////////////////////////////////
(0047) ////        (C) Copyright 1996, 2004 Custom Computer Services        ////
(0048) //// This source code may only be used by licensed users of the CCS  ////
(0049) //// C compiler.  This source code may only be distributed to other  ////
(0050) //// licensed users of the CCS C compiler.  No other use,            ////
(0051) //// reproduction or distribution is permitted without written       ////
(0052) //// permission.  Derivative programs created using this software    ////
(0053) //// in object code form are not restricted in any way.              ////
(0054) /////////////////////////////////////////////////////////////////////////
(0055) #include "math.h"
(0056) #include "mzl05.h"
(0057) #include "myGRAPHICS.h"
(0058) 
(0059) /////////////////////////////////////////////////////////////////////////
(0060) #ifndef GRAPHICS_DRAWING_FUNCTIONS
(0061) #define GRAPHICS_DRAWING_FUNCTIONS
(0062) #endif
(0063) /////////////////////////////////////////////////////////////////////////
(0064) 
(0065) 
(0066) /////////////////////////////////////////////////////////////////////////
(0067) #ifndef ON
(0068) #define ON  1
(0069) #endif
(0070) 
(0071) #ifndef OFF
(0072) #define OFF 0
(0073) #endif
(0074) 
(0075) #ifndef YES
(0076) #define YES 1
(0077) #endif
(0078) 
(0079) #ifndef NO
(0080) #define NO  0
(0081) #endif
(0082) /////////////////////////////////////////////////////////////////////////
(0083) //// Defines a 3x5 font
(0084) ////3x5 Font packed two per definition
(0085) /////////////////////////////////////////////////////////////////////////
(0086) #pragma data:code
(0087) const unsigned char TEXT35[96][5]={
(0088)    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b00000000, //SPACE
(0089)    0b01000100,   0b01000100,   0b01000100,   0b00000000,   0b01000100, //!
(0090)    0b10101010,   0b10101010,   0b00000000,   0b00000000,   0b00000000, //"
(0091)    0b10101010,   0b11101110,   0b10101010,   0b11101110,   0b10101010, //#
(0092)    0b01100110,   0b11001100,   0b11001100,   0b01100110,   0b11101110, //$
(0093)    0b10101010,   0b00100010,   0b01000100,   0b10001000,   0b10101010, //%
(0094)    0b01000100,   0b10101010,   0b01000100,   0b10101010,   0b01100110, //&
(0095)    0b01000100,   0b01000100,   0b00000000,   0b00000000,   0b00000000, //'
(0096)    0b01000100,   0b10001000,   0b10001000,   0b10001000,   0b01000100, //(
(0097)    0b01000100,   0b00100010,   0b00100010,   0b00100010,   0b01000100, //)
(0098)    0b00000000,   0b10101010,   0b01000100,   0b10101010,   0b00000000, //*
(0099)    0b00000000,   0b01000100,   0b11101110,   0b01000100,   0b00000000, //+
(0100)    0b00000000,   0b00000000,   0b00000000,   0b01000100,   0b10001000, //,
(0101)    0b00000000,   0b00000000,   0b11101110,   0b00000000,   0b00000000, //-
(0102)    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b01000100, //.
(0103)    0b00100010,   0b00100010,   0b01000100,   0b10001000,   0b10001000, ///
(0104)    0b11101110,   0b10101010,   0b10101010,   0b10101010,   0b11101110, //0
(0105)    0b01000100,   0b11001100,   0b01000100,   0b01000100,   0b11101110, //1
(0106)    0b11101110,   0b00100010,   0b11101110,   0b10001000,   0b11101110, //2
(0107)    0b11101110,   0b00100010,   0b11101110,   0b00100010,   0b11101110, //3
(0108)    0b10101010,   0b10101010,   0b11101110,   0b00100010,   0b00100010, //4
(0109)    0b11101110,   0b10001000,   0b11101110,   0b00100010,   0b11101110, //5
(0110)    0b11001100,   0b10001000,   0b11101110,   0b10101010,   0b11101110, //6
(0111)    0b11101110,   0b00100010,   0b01000100,   0b10001000,   0b10001000, //7
(0112)    0b11101110,   0b10101010,   0b11101110,   0b10101010,   0b11101110, //8
(0113)    0b11101110,   0b10101010,   0b11101110,   0b00100010,   0b01100110, //9
(0114)    0b00000000,   0b01000100,   0b00000000,   0b01000100,   0b00000000, //:
(0115)    0b00000000,   0b01000100,   0b00000000,   0b01000100,   0b10001000, //;
(0116)    0b00100010,   0b01000100,   0b10001000,   0b01000100,   0b00100010, //<
(0117)    0b00000000,   0b11101110,   0b00000000,   0b11101110,   0b00000000, //=
(0118)    0b10001000,   0b01000100,   0b00100010,   0b01000100,   0b10001000, //>
(0119)    0b11001100,   0b00100010,   0b01100110,   0b00000000,   0b01000100, //?
(0120)    0b01000100,   0b10101010,   0b11101110,   0b10001000,   0b01100110, //@
(0121)    0b11101110,   0b10101010,   0b11101110,   0b10101010,   0b10101010, //A
(0122)    0b11001100,   0b10101010,   0b11101110,   0b10101010,   0b11001100, //B
(0123)    0b11101110,   0b10001000,   0b10001000,   0b10001000,   0b11101110, //C
(0124)    0b11001100,   0b10101010,   0b10101010,   0b10101010,   0b11001100, //D
(0125)    0b11101110,   0b10001000,   0b11101110,   0b10001000,   0b11101110, //E
(0126)    0b11101110,   0b10001000,   0b11101110,   0b10001000,   0b10001000, //F
(0127)    0b11101110,   0b10001000,   0b10001000,   0b10101010,   0b11101110, //G
(0128)    0b10101010,   0b10101010,   0b11101110,   0b10101010,   0b10101010, //H
(0129)    0b11101110,   0b01000100,   0b01000100,   0b01000100,   0b11101110, //I
(0130)    0b00100010,   0b00100010,   0b00100010,   0b10101010,   0b11101110, //J
(0131)    0b10001000,   0b10101010,   0b11001100,   0b11001100,   0b10101010, //K
(0132)    0b10001000,   0b10001000,   0b10001000,   0b10001000,   0b11101110, //L
(0133)    0b10101010,   0b11101110,   0b11101110,   0b10101010,   0b10101010, //M
(0134)    0b00000000,   0b11001100,   0b10101010,   0b10101010,   0b10101010, //N
(0135)    0b01000100,   0b10101010,   0b10101010,   0b10101010,   0b01000100, //O
(0136)    0b11101110,   0b10101010,   0b11101110,   0b10001000,   0b10001000, //P
(0137)    0b01000100,   0b10101010,   0b10101010,   0b11101110,   0b01100110, //Q
(0138)    0b11101110,   0b10101010,   0b11001100,   0b11101110,   0b10101010, //R
(0139)    0b11101110,   0b10001000,   0b11101110,   0b00100010,   0b11101110, //S
(0140)    0b11101110,   0b01000100,   0b01000100,   0b01000100,   0b01000100, //T
(0141)    0b10101010,   0b10101010,   0b10101010,   0b10101010,   0b11101110, //U
(0142)    0b10101010,   0b10101010,   0b10101010,   0b10101010,   0b01000100, //V
(0143)    0b10101010,   0b10101010,   0b11101110,   0b11101110,   0b10101010, //W
(0144)    0b00000000,   0b10101010,   0b01000100,   0b01000100,   0b10101010, //X
(0145)    0b10101010,   0b10101010,   0b01000100,   0b01000100,   0b01000100, //Y
(0146)    0b11101110,   0b00100010,   0b01000100,   0b10001000,   0b11101110, //Z
(0147)    0b11101110,   0b10001000,   0b10001000,   0b10001000,   0b11101110, //[
(0148)    0b10001000,   0b10001000,   0b01000100,   0b00100010,   0b00100010, //\
(0149)    0b11101110,   0b00100010,   0b00100010,   0b00100010,   0b11101110, //]
(0150)    0b01000100,   0b10101010,   0b00000000,   0b00000000,   0b00000000, //^
(0151)    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b11101110, //_
(0152)    0b10001000,   0b01000100,   0b00000000,   0b00000000,   0b00000000, //`
(0153)    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b00000000, //SPACE
(0154)    0b00000000, 0b01000100, 0b10101010, 0b10101010, 0b01100110, //a
(0155)    0b10001000, 0b11001100, 0b10101010, 0b10101010, 0b11001100, //b
(0156)    0b00000000,   0b01100110, 0b10001000, 0b10001000, 0b01100110, //c
(0157)    0b00100010,   0b01100110, 0b10101010, 0b10101010, 0b01100110, //d
(0158)    0b00000000, 0b01000100, 0b10101010, 0b11001100, 0b01100110, //e
(0159)    0b01100110,   0b01000100, 0b11101110, 0b01000100, 0b01000100, //f
(0160)    0b00000000, 0b01000100, 0b10101010, 0b01100110, 0b11001100, //g
(0161)    0b10001000, 0b11001100, 0b10101010, 0b10101010, 0b10101010, //h
(0162)    0b01000100,   0b00000000, 0b01000100, 0b01000100, 0b01000100, //i
(0163)    0b01000100, 0b00000000, 0b01000100, 0b01000100, 0b10001000, //j
(0164)    0b10001000,   0b10001000, 0b10101010, 0b11001100, 0b10101010, //k
(0165)    0b01000100,   0b01000100, 0b01000100, 0b01000100, 0b01000100, //l
(0166)    0b00000000,   0b11101110, 0b11101110, 0b10101010, 0b10101010, //m
(0167)    0b00000000,   0b11001100, 0b10101010, 0b10101010, 0b10101010, //n
(0168)    0b00000000,   0b01000100, 0b10101010, 0b10101010, 0b01000100, //o
(0169)    0b00000000,   0b11001100, 0b10101010, 0b11001100, 0b10001000, //p
(0170)    0b00000000,   0b01100110, 0b10101010, 0b01100110, 0b00100010, //q
(0171)    0b00000000,   0b10001000, 0b11101110, 0b10001000, 0b10001000, //r
(0172)    0b00000000, 0b01100110, 0b11001100, 0b00100010, 0b11001100, //s
(0173)    0b01000100,   0b11101110, 0b01000100, 0b01000100, 0b01000100, //t
(0174)    0b00000000, 0b10101010, 0b10101010, 0b10101010, 0b01000100, //u
(0175)    0b00000000, 0b10101010, 0b10101010, 0b01000100, 0b01000100, //v
(0176)    0b00000000,   0b10101010, 0b10101010, 0b11101110, 0b10101010, //w
(0177)    0b00000000,   0b10101010, 0b01000100, 0b01000100, 0b10101010, //x
(0178)    0b00000000,   0b10101010, 0b10101010, 0b01100110, 0b11001100, //y
(0179)    0b00000000, 0b11101110, 0b01100110, 0b11001100, 0b11101110, //z
(0180)    0b00100010,   0b01000100,   0b11001100,   0b01000100,   0b00100010, //{
(0181)    0b01000100,   0b01000100,   0b01000100,   0b01000100,   0b01000100, //|
(0182)    0b10001000,   0b01000100,   0b01100110,   0b01000100,   0b10001000, //}
(0183)    0b00000000,   0b11001100,   0b10101010,   0b00000000,   0b00000000  //~
(0184)    };
(0185) 
(0186) /////////////////////////////////////////////////////////////////////////
(0187) //// Defines a 5x7 font
(0188) /////////////////////////////////////////////////////////////////////////
(0189) const unsigned char FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
(0190)                          0x00, 0x00, 0x5F, 0x00, 0x00, // !
(0191)                          0x00, 0x03, 0x00, 0x03, 0x00, // "
(0192)                          0x14, 0x3E, 0x14, 0x3E, 0x14, // #
(0193)                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
(0194)                          0x43, 0x33, 0x08, 0x66, 0x61, // %
(0195)                          0x36, 0x49, 0x55, 0x22, 0x50, // &
(0196)                          0x00, 0x05, 0x03, 0x00, 0x00, // '
(0197)                          0x00, 0x1C, 0x22, 0x41, 0x00, // (
(0198)                          0x00, 0x41, 0x22, 0x1C, 0x00, // )
(0199)                          0x14, 0x08, 0x3E, 0x08, 0x14, // *
(0200)                          0x08, 0x08, 0x3E, 0x08, 0x08, // +
(0201)                          0x00, 0x50, 0x30, 0x00, 0x00, // ,
(0202)                          0x08, 0x08, 0x08, 0x08, 0x08, // -
(0203)                          0x00, 0x60, 0x60, 0x00, 0x00, // .
(0204)                          0x20, 0x10, 0x08, 0x04, 0x02, // /
(0205)                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
(0206)                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1
(0207)                          0x42, 0x61, 0x51, 0x49, 0x46, // 2
(0208)                          0x22, 0x41, 0x49, 0x49, 0x36, // 3
(0209)                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4
(0210)                          0x27, 0x45, 0x45, 0x45, 0x39, // 5
(0211)                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6
(0212)                          0x01, 0x01, 0x71, 0x09, 0x07, // 7
(0213)                          0x36, 0x49, 0x49, 0x49, 0x36, // 8
(0214)                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9
(0215)                          0x00, 0x36, 0x36, 0x00, 0x00, // :
(0216)                          0x00, 0x56, 0x36, 0x00, 0x00, // ;
(0217)                          0x08, 0x14, 0x22, 0x41, 0x00, // <
(0218)                          0x14, 0x14, 0x14, 0x14, 0x14, // =
(0219)                          0x00, 0x41, 0x22, 0x14, 0x08, // >
(0220)                          0x02, 0x01, 0x51, 0x09, 0x06, // ?
(0221)                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @
(0222)                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A
(0223)                          0x7F, 0x49, 0x49, 0x49, 0x36, // B
(0224)                          0x3E, 0x41, 0x41, 0x41, 0x22, // C
(0225)                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D
(0226)                          0x7F, 0x49, 0x49, 0x49, 0x41, // E
(0227)                          0x7F, 0x09, 0x09, 0x09, 0x01, // F
(0228)                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G
(0229)                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H
(0230)                          0x00, 0x41, 0x7F, 0x41, 0x00, // I
(0231)                          0x30, 0x40, 0x40, 0x40, 0x3F, // J
(0232)                          0x7F, 0x08, 0x14, 0x22, 0x41, // K
(0233)                          0x7F, 0x40, 0x40, 0x40, 0x40, // L
(0234)                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
(0235)                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N
(0236)                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O
(0237)                          0x7F, 0x09, 0x09, 0x09, 0x06, // P
(0238)                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
(0239)                          0x7F, 0x09, 0x09, 0x09, 0x76};// R
(0240) 
(0241) const unsigned char FONT2[45][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
(0242)                          0x01, 0x01, 0x7F, 0x01, 0x01, // T
(0243)                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U
(0244)                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V
(0245)                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W
(0246)                          0x41, 0x22, 0x1C, 0x22, 0x41, // X
(0247)                          0x07, 0x08, 0x70, 0x08, 0x07, // Y
(0248)                          0x61, 0x51, 0x49, 0x45, 0x43, // Z
(0249)                          0x00, 0x7F, 0x41, 0x00, 0x00, // [
(0250)                          0x02, 0x04, 0x08, 0x10, 0x20, // \
(0251)                          0x00, 0x00, 0x41, 0x7F, 0x00, // ]
(0252)                          0x04, 0x02, 0x01, 0x02, 0x04, // ^
(0253)                          0x40, 0x40, 0x40, 0x40, 0x40, // _
(0254)                          0x00, 0x01, 0x02, 0x04, 0x00, // `
(0255)                          0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
(0256) 						 0x20, 0x54, 0x54, 0x54, 0x78, // a
(0257)                          0x7F, 0x44, 0x44, 0x44, 0x38, // b
(0258)                          0x38, 0x44, 0x44, 0x44, 0x44, // c
(0259)                          0x38, 0x44, 0x44, 0x44, 0x7F, // d
(0260)                          0x38, 0x54, 0x54, 0x54, 0x18, // e
(0261)                          0x04, 0x04, 0x7E, 0x05, 0x05, // f
(0262)                          0x08, 0x54, 0x54, 0x54, 0x3C, // g
(0263)                          0x7F, 0x08, 0x04, 0x04, 0x78, // h
(0264)                          0x00, 0x44, 0x7D, 0x40, 0x00, // i
(0265)                          0x20, 0x40, 0x44, 0x3D, 0x00, // j
(0266)                          0x7F, 0x10, 0x28, 0x44, 0x00, // k
(0267)                          0x00, 0x41, 0x7F, 0x40, 0x00, // l
(0268)                          0x7C, 0x04, 0x78, 0x04, 0x78, // m
(0269)                          0x7C, 0x08, 0x04, 0x04, 0x78, // n
(0270)                          0x38, 0x44, 0x44, 0x44, 0x38, // o
(0271)                          0x7C, 0x14, 0x14, 0x14, 0x08, // p
(0272)                          0x08, 0x14, 0x14, 0x14, 0x7C, // q
(0273)                          0x00, 0x7C, 0x08, 0x04, 0x04, // r
(0274)                          0x48, 0x54, 0x54, 0x54, 0x20, // s
(0275)                          0x04, 0x04, 0x3F, 0x44, 0x44, // t
(0276)                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u
(0277)                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v
(0278)                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w
(0279)                          0x44, 0x28, 0x10, 0x28, 0x44, // x
(0280)                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y
(0281)                          0x44, 0x64, 0x54, 0x4C, 0x44, // z
(0282)                          0x00, 0x08, 0x36, 0x41, 0x41, // {
(0283)                          0x00, 0x00, 0x7F, 0x00, 0x00, // |
(0284)                          0x41, 0x41, 0x36, 0x08, 0x00, // }
(0285)                          0x02, 0x01, 0x02, 0x04, 0x02};// ~
(0286) /////////////////////////////////////////////////////////////////////////
(0287) #pragma data:data
(0288) /////////////////////////////////////////////////////////////////////////
(0289) // Purpose:       Draw a line on a graphic LCD using Bresenham's
(0290) //                line drawing algorithm
(0291) // Inputs:        (x1, y1) - the start coordinate
(0292) //                (x2, y2) - the end coordinate
(0293) //                color - ON or OFF
(0294) // Dependencies:  glcd_pixel()
(0295) /////////////////////////////////////////////////////////////////////////
(0296) //#ifdef LARGE_LCD
(0297) //void glcd_line(int x1, int y1, int x2, int y2, char color)
(0298) //#else
(0299) void glcd_line(char x1, char y1, char x2, char y2, char color)
(0300) //#endif
(0301) {
(0302)    int        dy, dx;
(0303)    signed char  addx=1, addy=1;
    0239 2400      CLR	R0
    023A 9403      INC	R0
    023B 820B      STD	Y+3,R0
    023C E041      LDI	R20,1
(0304)    int P, diff;
(0305) 
(0306)    #ifdef LARGE_LCD
(0307)    int i=0;
(0308)    dx = abs((signed int)(x2 - x1));
(0309)    dy = abs((signed int)(y2 - y1));
(0310)    #else
(0311)    char i=0;
    023D 24EE      CLR	R14
(0312)    dx = abs((signed char)(x2 - x1));
    023E 842E      LDD	R2,Y+14
    023F 2433      CLR	R3
    0240 890A      LDD	R16,Y+18
    0241 2711      CLR	R17
    0242 1902      SUB	R16,R2
    0243 0913      SBC	R17,R3
    0244 2711      CLR	R17
    0245 FD07      SBRC	R16,7
    0246 9510      COM	R17
    0247 940E08D2  CALL	_abs
    0249 0158      MOVW	R10,R16
(0313)    dy = abs((signed char)(y2 - y1));
    024A 8828      LDD	R2,Y+16
    024B 2433      CLR	R3
    024C 890C      LDD	R16,Y+20
    024D 2711      CLR	R17
    024E 1902      SUB	R16,R2
    024F 0913      SBC	R17,R3
    0250 2711      CLR	R17
    0251 FD07      SBRC	R16,7
    0252 9510      COM	R17
    0253 940E08D2  CALL	_abs
    0255 0168      MOVW	R12,R16
(0314)    #endif
(0315) 
(0316)    if(x1 > x2)
    0256 880A      LDD	R0,Y+18
    0257 850E      LDD	R16,Y+14
    0258 1600      CP	R0,R16
    0259 F410      BCC	0x025C
(0317)       addx = -1;
    025A EF8F      LDI	R24,0xFF
    025B 838B      STD	Y+3,R24
(0318)    if(y1 > y2)
    025C 880C      LDD	R0,Y+20
    025D 8908      LDD	R16,Y+16
    025E 1600      CP	R0,R16
    025F F408      BCC	0x0261
(0319)       addy = -1;
    0260 EF4F      LDI	R20,0xFF
(0320) 
(0321)    if(dx >= dy)
    0261 14AC      CP	R10,R12
    0262 04BD      CPC	R11,R13
    0263 F194      BLT	0x0296
(0322)    {
(0323)       dy *= 2;
    0264 E002      LDI	R16,2
    0265 E010      LDI	R17,0
    0266 0196      MOVW	R18,R12
    0267 940E092F  CALL	empy16s
    0269 0168      MOVW	R12,R16
(0324)       P = dy - dx;
    026A 01B6      MOVW	R22,R12
    026B 196A      SUB	R22,R10
    026C 097B      SBC	R23,R11
(0325)       diff = P - dx;
    026D 011B      MOVW	R2,R22
    026E 182A      SUB	R2,R10
    026F 083B      SBC	R3,R11
    0270 823A      STD	Y+2,R3
    0271 8229      STD	Y+1,R2
(0326) 
(0327)       for(; i<=dx; ++i)
    0272 C01D      RJMP	0x0290
(0328)       {
(0329)          glcd_pixel(x1, y1, color);
    0273 880E      LDD	R0,Y+22
    0274 8208      STD	Y+0,R0
    0275 8928      LDD	R18,Y+16
    0276 850E      LDD	R16,Y+14
    0277 940E0769  CALL	_glcd_pixel
(0330) 
(0331)          if(P < 0)
    0279 3060      CPI	R22,0
    027A E0E0      LDI	R30,0
    027B 077E      CPC	R23,R30
    027C F43C      BGE	0x0284
(0332)          {
(0333)             P  += dy;
    027D 0D6C      ADD	R22,R12
    027E 1D7D      ADC	R23,R13
(0334)             x1 += addx;
    027F 840E      LDD	R0,Y+14
    0280 810B      LDD	R16,Y+3
    0281 0E00      ADD	R0,R16
    0282 860E      STD	Y+14,R0
(0335)          }
    0283 C00B      RJMP	0x028F
(0336)          else
(0337)          {
(0338)             P  += diff;
    0284 8029      LDD	R2,Y+1
    0285 803A      LDD	R3,Y+2
    0286 0D62      ADD	R22,R2
    0287 1D73      ADC	R23,R3
(0339)             x1 += addx;
    0288 840E      LDD	R0,Y+14
    0289 810B      LDD	R16,Y+3
    028A 0E00      ADD	R0,R16
    028B 860E      STD	Y+14,R0
(0340)             y1 += addy;
    028C 8808      LDD	R0,Y+16
    028D 0E04      ADD	R0,R20
    028E 8A08      STD	Y+16,R0
    028F 94E3      INC	R14
    0290 2C2E      MOV	R2,R14
    0291 2433      CLR	R3
    0292 14A2      CP	R10,R2
    0293 04B3      CPC	R11,R3
    0294 F6F4      BGE	0x0273
(0341)          }
(0342)       }
(0343)    }
    0295 C030      RJMP	0x02C6
(0344)    else
(0345)    {
(0346)       dx *= 2;
    0296 E002      LDI	R16,2
    0297 E010      LDI	R17,0
    0298 0195      MOVW	R18,R10
    0299 940E092F  CALL	empy16s
    029B 0158      MOVW	R10,R16
(0347)       P = dx - dy;
    029C 01B5      MOVW	R22,R10
    029D 196C      SUB	R22,R12
    029E 097D      SBC	R23,R13
(0348)       diff = P - dy;
    029F 011B      MOVW	R2,R22
    02A0 182C      SUB	R2,R12
    02A1 083D      SBC	R3,R13
    02A2 823A      STD	Y+2,R3
    02A3 8229      STD	Y+1,R2
(0349) 
(0350)       for(; i<=dy; ++i)
    02A4 C01C      RJMP	0x02C1
(0351)       {
(0352)          glcd_pixel(x1, y1, color);
    02A5 880E      LDD	R0,Y+22
    02A6 8208      STD	Y+0,R0
    02A7 8928      LDD	R18,Y+16
    02A8 850E      LDD	R16,Y+14
    02A9 940E0769  CALL	_glcd_pixel
(0353) 
(0354)          if(P < 0)
    02AB 3060      CPI	R22,0
    02AC E0E0      LDI	R30,0
    02AD 077E      CPC	R23,R30
    02AE F434      BGE	0x02B5
(0355)          {
(0356)             P  += dx;
    02AF 0D6A      ADD	R22,R10
    02B0 1D7B      ADC	R23,R11
(0357)             y1 += addy;
    02B1 8808      LDD	R0,Y+16
    02B2 0E04      ADD	R0,R20
    02B3 8A08      STD	Y+16,R0
(0358)          }
    02B4 C00B      RJMP	0x02C0
(0359)          else
(0360)          {
(0361)             P  += diff;
    02B5 8029      LDD	R2,Y+1
    02B6 803A      LDD	R3,Y+2
    02B7 0D62      ADD	R22,R2
    02B8 1D73      ADC	R23,R3
(0362)             x1 += addx;
    02B9 840E      LDD	R0,Y+14
    02BA 810B      LDD	R16,Y+3
    02BB 0E00      ADD	R0,R16
    02BC 860E      STD	Y+14,R0
(0363)             y1 += addy;
    02BD 8808      LDD	R0,Y+16
    02BE 0E04      ADD	R0,R20
    02BF 8A08      STD	Y+16,R0
    02C0 94E3      INC	R14
    02C1 2C2E      MOV	R2,R14
    02C2 2433      CLR	R3
    02C3 14C2      CP	R12,R2
    02C4 04D3      CPC	R13,R3
    02C5 F6FC      BGE	0x02A5
(0364)          }
(0365)       }
(0366)    }
    02C6 9624      ADIW	R28,4
    02C7 940E0948  CALL	pop_gset5
    02C9 9624      ADIW	R28,4
    02CA 9508      RET
_glcd_rect:
  ymin                 --> R14
  xmax                 --> R10
  ymax                 --> R22
  xmin                 --> R20
  i                    --> R12
  color                --> Y+25
  fill                 --> Y+23
  y2                   --> Y+21
  x2                   --> Y+19
  y1                   --> Y+17
  x1                   --> Y+15
    02CB 940E08D8  CALL	push_arg4
    02CD 940E094B  CALL	push_gset5
    02CF 9725      SBIW	R28,5
(0367) }
(0368) 
(0369) 
(0370) /////////////////////////////////////////////////////////////////////////
(0371) // Purpose:       Draw a rectangle on a graphic LCD
(0372) // Inputs:        (x1, y1) - the start coordinate
(0373) //                (x2, y2) - the end coordinate
(0374) //                fill  - YES or NO
(0375) //                color - ON or OFF
(0376) // Dependencies:  glcd_pixel(), glcd_line()
(0377) /////////////////////////////////////////////////////////////////////////
(0378) //#ifdef LARGE_LCD
(0379) //void glcd_rect(int x1, int y1, int x2, int y2, char fill, char color)
(0380) //#else
(0381) void glcd_rect(char x1, char y1, char x2, char y2, char fill, char color)
(0382) //#endif
(0383) {
(0384)    if(fill==1)
    02D0 898F      LDD	R24,Y+23
    02D1 3081      CPI	R24,1
    02D2 F511      BNE	0x02F5
(0385)    {
(0386)       #ifdef LARGE_LCD
(0387)       int i, xmin, xmax, ymin, ymax;
(0388)       #else
(0389)       char  i, xmin, xmax, ymin, ymax;
(0390)       #endif
(0391) 
(0392)       if(x1 < x2)                            //  Find x min and max
    02D3 840F      LDD	R0,Y+15
    02D4 890B      LDD	R16,Y+19
    02D5 1600      CP	R0,R16
    02D6 F418      BCC	0x02DA
(0393)       {
(0394)          xmin = x1;
    02D7 2D40      MOV	R20,R0
(0395)          xmax = x2;
    02D8 2EA0      MOV	R10,R16
(0396)       }
    02D9 C002      RJMP	0x02DC
(0397)       else
(0398)       {
(0399)          xmin = x2;
    02DA 894B      LDD	R20,Y+19
(0400)          xmax = x1;
    02DB 84AF      LDD	R10,Y+15
(0401)       }
(0402) 
(0403)       if(y1 < y2)                            // Find the y min and max
    02DC 8809      LDD	R0,Y+17
    02DD 890D      LDD	R16,Y+21
    02DE 1600      CP	R0,R16
    02DF F418      BCC	0x02E3
(0404)       {
(0405)          ymin = y1;
    02E0 2CE0      MOV	R14,R0
(0406)          ymax = y2;
    02E1 2F60      MOV	R22,R16
(0407)       }
    02E2 C00F      RJMP	0x02F2
(0408)       else
(0409)       {
(0410)          ymin = y2;
    02E3 88ED      LDD	R14,Y+21
(0411)          ymax = y1;
    02E4 8969      LDD	R22,Y+17
(0412)       }
(0413) 
(0414)       for(; xmin <= xmax; ++xmin)
    02E5 C00C      RJMP	0x02F2
(0415)       {
(0416)          for(i=ymin; i<=ymax; ++i)
    02E6 2CCE      MOV	R12,R14
    02E7 C007      RJMP	0x02EF
(0417)          {
(0418)             glcd_pixel(xmin, i, color);
    02E8 8C09      LDD	R0,Y+25
    02E9 8208      STD	Y+0,R0
    02EA 2D2C      MOV	R18,R12
    02EB 2F04      MOV	R16,R20
    02EC 940E0769  CALL	_glcd_pixel
    02EE 94C3      INC	R12
    02EF 156C      CP	R22,R12
    02F0 F7B8      BCC	0x02E8
    02F1 9543      INC	R20
    02F2 16A4      CP	R10,R20
    02F3 F790      BCC	0x02E6
(0419)          }
(0420)       }
(0421)    }
    02F4 C024      RJMP	0x0319
(0422)    else
(0423)    {
(0424)       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides
    02F5 8C09      LDD	R0,Y+25
    02F6 820C      STD	Y+4,R0
    02F7 8809      LDD	R0,Y+17
    02F8 820A      STD	Y+2,R0
    02F9 880B      LDD	R0,Y+19
    02FA 8208      STD	Y+0,R0
    02FB 8929      LDD	R18,Y+17
    02FC 850F      LDD	R16,Y+15
    02FD DF36      RCALL	_glcd_line
(0425)       glcd_line(x1, y2, x2, y2, color);
    02FE 8C09      LDD	R0,Y+25
    02FF 820C      STD	Y+4,R0
    0300 880D      LDD	R0,Y+21
    0301 820A      STD	Y+2,R0
    0302 880B      LDD	R0,Y+19
    0303 8208      STD	Y+0,R0
    0304 892D      LDD	R18,Y+21
    0305 850F      LDD	R16,Y+15
    0306 DF2D      RCALL	_glcd_line
(0426)       glcd_line(x1, y1, x1, y2, color);
    0307 8C09      LDD	R0,Y+25
    0308 820C      STD	Y+4,R0
    0309 880D      LDD	R0,Y+21
    030A 820A      STD	Y+2,R0
    030B 840F      LDD	R0,Y+15
    030C 8208      STD	Y+0,R0
    030D 8929      LDD	R18,Y+17
    030E 2D00      MOV	R16,R0
    030F DF24      RCALL	_glcd_line
(0427)       glcd_line(x2, y1, x2, y2, color);
    0310 8C09      LDD	R0,Y+25
    0311 820C      STD	Y+4,R0
    0312 880D      LDD	R0,Y+21
    0313 820A      STD	Y+2,R0
    0314 880B      LDD	R0,Y+19
    0315 8208      STD	Y+0,R0
    0316 8929      LDD	R18,Y+17
    0317 2D00      MOV	R16,R0
    0318 DF1B      RCALL	_glcd_line
(0428)    }
    0319 9625      ADIW	R28,5
    031A 940E0948  CALL	pop_gset5
    031C 9624      ADIW	R28,4
    031D 9508      RET
_glcd_bar:
  temp                 --> R10
  temp                 --> R10
  temp                 --> Y+9
  temp                 --> Y+9
  diff                 --> Y+7
  addy                 --> Y+13
  addx                 --> Y+12
  i                    --> Y+11
  P                    --> Y+5
  c2                   --> Y+3
  c1                   --> Y+1
  half_width           --> R12
  dx                   --> R14
  dy                   --> R22
  j                    --> R20
  color                --> Y+34
  width                --> Y+32
  y2                   --> Y+30
  x2                   --> Y+28
  y1                   --> Y+26
  x1                   --> Y+24
    031E 940E08D8  CALL	push_arg4
    0320 940E094B  CALL	push_gset5
    0322 972E      SBIW	R28,0xE
(0429) }
(0430) 
(0431) /////////////////////////////////////////////////////////////////////////
(0432) // Purpose:       Draw a bar (wide line) on a graphic LCD
(0433) // Inputs:        (x1, y1) - the start coordinate
(0434) //                (x2, y2) - the end coordinate
(0435) //                width  - The number of pixels wide
(0436) //                color - ON or OFF
(0437) /////////////////////////////////////////////////////////////////////////
(0438) //#ifdef LARGE_LCD
(0439) //void glcd_bar(int x1, int y1, int x2, int y2, char width, char color)
(0440) //#else
(0441) void glcd_bar(char x1, char y1, char x2, char y2, char width, char color)
(0442) //#endif
(0443) {
(0444)    char         half_width;
(0445)    signed int dy, dx;
(0446)    signed char  addx=1, addy=1, j;
    0323 2400      CLR	R0
    0324 9403      INC	R0
    0325 860C      STD	Y+12,R0
    0326 860D      STD	Y+13,R0
(0447)    signed int P, diff, c1, c2;
(0448) 
(0449)    #ifdef LARGE_LCD
(0450)    int i=0;
(0451)    dx = abs((signed int)(x2 - x1));
(0452)    dy = abs((signed int)(y2 - y1));
(0453)    #else
(0454)    char i=0;
    0327 2400      CLR	R0
    0328 860B      STD	Y+11,R0
(0455)    dx = abs((signed char)(x2 - x1));
    0329 8C28      LDD	R2,Y+24
    032A 2433      CLR	R3
    032B 8D0C      LDD	R16,Y+28
    032C 2711      CLR	R17
    032D 1902      SUB	R16,R2
    032E 0913      SBC	R17,R3
    032F 2711      CLR	R17
    0330 FD07      SBRC	R16,7
    0331 9510      COM	R17
    0332 940E08D2  CALL	_abs
    0334 0178      MOVW	R14,R16
(0456)    dy = abs((signed char)(y2 - y1));
    0335 8C2A      LDD	R2,Y+26
    0336 2433      CLR	R3
    0337 8D0E      LDD	R16,Y+30
    0338 2711      CLR	R17
    0339 1902      SUB	R16,R2
    033A 0913      SBC	R17,R3
    033B 2711      CLR	R17
    033C FD07      SBRC	R16,7
    033D 9510      COM	R17
    033E 940E08D2  CALL	_abs
    0340 01B8      MOVW	R22,R16
(0457)    #endif
(0458) 
(0459)    half_width = width/2;
    0341 A0C8      LDD	R12,Y+32
    0342 94C6      LSR	R12
(0460)    c1 = -(dx*x1 + dy*y1);
    0343 8D2A      LDD	R18,Y+26
    0344 2733      CLR	R19
    0345 940E092F  CALL	empy16s
    0347 0118      MOVW	R2,R16
    0348 8D28      LDD	R18,Y+24
    0349 2733      CLR	R19
    034A 0187      MOVW	R16,R14
    034B 940E092F  CALL	empy16s
    034D 01C8      MOVW	R24,R16
    034E 0D82      ADD	R24,R2
    034F 1D93      ADC	R25,R3
    0350 9580      COM	R24
    0351 9590      COM	R25
    0352 5F8F      SUBI	R24,0xFF
    0353 4F9F      SBCI	R25,0xFF
    0354 839A      STD	Y+2,R25
    0355 8389      STD	Y+1,R24
(0461)    c2 = -(dx*x2 + dy*y2);
    0356 8D2E      LDD	R18,Y+30
    0357 2733      CLR	R19
    0358 018B      MOVW	R16,R22
    0359 940E092F  CALL	empy16s
    035B 0118      MOVW	R2,R16
    035C 8D2C      LDD	R18,Y+28
    035D 2733      CLR	R19
    035E 0187      MOVW	R16,R14
    035F 940E092F  CALL	empy16s
    0361 01C8      MOVW	R24,R16
    0362 0D82      ADD	R24,R2
    0363 1D93      ADC	R25,R3
    0364 9580      COM	R24
    0365 9590      COM	R25
    0366 5F8F      SUBI	R24,0xFF
    0367 4F9F      SBCI	R25,0xFF
    0368 839C      STD	Y+4,R25
    0369 838B      STD	Y+3,R24
(0462) 
(0463)    if(x1 > x2)
    036A 8C0C      LDD	R0,Y+28
    036B 8D08      LDD	R16,Y+24
    036C 1600      CP	R0,R16
    036D F470      BCC	0x037C
(0464)    {
(0465)       signed int temp;
(0466)       temp = c1;
    036E 8029      LDD	R2,Y+1
    036F 803A      LDD	R3,Y+2
    0370 863A      STD	Y+10,R3
    0371 8629      STD	Y+9,R2
(0467)       c1 = c2;
    0372 802B      LDD	R2,Y+3
    0373 803C      LDD	R3,Y+4
    0374 823A      STD	Y+2,R3
    0375 8229      STD	Y+1,R2
(0468)       c2 = temp;
    0376 8429      LDD	R2,Y+9
    0377 843A      LDD	R3,Y+10
    0378 823C      STD	Y+4,R3
    0379 822B      STD	Y+3,R2
(0469)       addx = -1;
    037A EF8F      LDI	R24,0xFF
    037B 878C      STD	Y+12,R24
(0470)    }
(0471)    if(y1 > y2)
    037C 8C0E      LDD	R0,Y+30
    037D 8D0A      LDD	R16,Y+26
    037E 1600      CP	R0,R16
    037F F470      BCC	0x038E
(0472)    {
(0473)       signed int temp;
(0474)       temp = c1;
    0380 8029      LDD	R2,Y+1
    0381 803A      LDD	R3,Y+2
    0382 863A      STD	Y+10,R3
    0383 8629      STD	Y+9,R2
(0475)       c1 = c2;
    0384 802B      LDD	R2,Y+3
    0385 803C      LDD	R3,Y+4
    0386 823A      STD	Y+2,R3
    0387 8229      STD	Y+1,R2
(0476)       c2 = temp;
    0388 8429      LDD	R2,Y+9
    0389 843A      LDD	R3,Y+10
    038A 823C      STD	Y+4,R3
    038B 822B      STD	Y+3,R2
(0477)       addy = -1;
    038C EF8F      LDI	R24,0xFF
    038D 878D      STD	Y+13,R24
(0478)    }
(0479) 
(0480)    if(dx >= dy)
    038E 16E6      CP	R14,R22
    038F 06F7      CPC	R15,R23
    0390 F40C      BGE	0x0392
    0391 C07D      RJMP	0x040F
(0481)    {
(0482)       P = 2*dy - dx;
    0392 E002      LDI	R16,2
    0393 E010      LDI	R17,0
    0394 019B      MOVW	R18,R22
    0395 940E092F  CALL	empy16s
    0397 0118      MOVW	R2,R16
    0398 182E      SUB	R2,R14
    0399 083F      SBC	R3,R15
    039A 823E      STD	Y+6,R3
    039B 822D      STD	Y+5,R2
(0483)       diff = P - dx;
    039C 182E      SUB	R2,R14
    039D 083F      SBC	R3,R15
    039E 8638      STD	Y+8,R3
    039F 822F      STD	Y+7,R2
(0484) 
(0485)       for(i=0; i<=dx; ++i)
    03A0 2400      CLR	R0
    03A1 860B      STD	Y+11,R0
    03A2 C065      RJMP	0x0408
(0486)       {
(0487)          for(j=-half_width; j<half_width+width%2; ++j)
    03A3 2D4C      MOV	R20,R12
    03A4 9541      NEG	R20
    03A5 C031      RJMP	0x03D7
(0488)          {
(0489)             #ifdef LARGE_LCD
(0490)             int temp;
(0491)             #else
(0492)             char temp;
(0493)             #endif
(0494) 
(0495)             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed
    03A6 2E24      MOV	R2,R20
    03A7 2433      CLR	R3
    03A8 FC27      SBRC	R2,7
    03A9 9430      COM	R3
    03AA 8D2A      LDD	R18,Y+26
    03AB 2733      CLR	R19
    03AC 0D22      ADD	R18,R2
    03AD 1D33      ADC	R19,R3
    03AE 018B      MOVW	R16,R22
    03AF 940E092F  CALL	empy16s
    03B1 0118      MOVW	R2,R16
    03B2 8D28      LDD	R18,Y+24
    03B3 2733      CLR	R19
    03B4 0187      MOVW	R16,R14
    03B5 940E092F  CALL	empy16s
    03B7 2EA0      MOV	R10,R16
    03B8 0CA2      ADD	R10,R2
    03B9 1CB3      ADC	R11,R3
(0496)             if(temp+c1 >= 0 && temp+c2 <=0)
    03BA 8029      LDD	R2,Y+1
    03BB 803A      LDD	R3,Y+2
    03BC 2D8A      MOV	R24,R10
    03BD 2799      CLR	R25
    03BE 0D82      ADD	R24,R2
    03BF 1D93      ADC	R25,R3
    03C0 3080      CPI	R24,0
    03C1 E0E0      LDI	R30,0
    03C2 079E      CPC	R25,R30
    03C3 F094      BLT	0x03D6
    03C4 802B      LDD	R2,Y+3
    03C5 803C      LDD	R3,Y+4
    03C6 2C4A      MOV	R4,R10
    03C7 2455      CLR	R5
    03C8 0C42      ADD	R4,R2
    03C9 1C53      ADC	R5,R3
    03CA 2422      CLR	R2
    03CB 2433      CLR	R3
    03CC 1424      CP	R2,R4
    03CD 0435      CPC	R3,R5
    03CE F03C      BLT	0x03D6
(0497)                glcd_pixel(x1, y1+j, color);
    03CF A00A      LDD	R0,Y+34
    03D0 8208      STD	Y+0,R0
    03D1 8D2A      LDD	R18,Y+26
    03D2 0F24      ADD	R18,R20
    03D3 8D08      LDD	R16,Y+24
    03D4 940E0769  CALL	_glcd_pixel
    03D6 9543      INC	R20
    03D7 E012      LDI	R17,2
    03D8 A108      LDD	R16,Y+32
    03D9 940E0917  CALL	mod8u
    03DB 2C2C      MOV	R2,R12
    03DC 0E20      ADD	R2,R16
    03DD 1542      CP	R20,R2
    03DE F238      BCS	0x03A6
(0498)          }
(0499)          if(P < 0)
    03DF 818D      LDD	R24,Y+5
    03E0 819E      LDD	R25,Y+6
    03E1 3080      CPI	R24,0
    03E2 E0E0      LDI	R30,0
    03E3 079E      CPC	R25,R30
    03E4 F484      BGE	0x03F5
(0500)          {
(0501)             P  += 2*dy;
    03E5 E002      LDI	R16,2
    03E6 E010      LDI	R17,0
    03E7 019B      MOVW	R18,R22
    03E8 940E092F  CALL	empy16s
    03EA 802D      LDD	R2,Y+5
    03EB 803E      LDD	R3,Y+6
    03EC 0E20      ADD	R2,R16
    03ED 1E31      ADC	R3,R17
    03EE 823E      STD	Y+6,R3
    03EF 822D      STD	Y+5,R2
(0502)             x1 += addx;
    03F0 8C08      LDD	R0,Y+24
    03F1 850C      LDD	R16,Y+12
    03F2 0E00      ADD	R0,R16
    03F3 8E08      STD	Y+24,R0
(0503)          }
    03F4 C010      RJMP	0x0405
(0504)          else
(0505)          {
(0506)             P  += diff;
    03F5 802F      LDD	R2,Y+7
    03F6 8438      LDD	R3,Y+8
    03F7 804D      LDD	R4,Y+5
    03F8 805E      LDD	R5,Y+6
    03F9 0C42      ADD	R4,R2
    03FA 1C53      ADC	R5,R3
    03FB 825E      STD	Y+6,R5
    03FC 824D      STD	Y+5,R4
(0507)             x1 += addx;
    03FD 8C08      LDD	R0,Y+24
    03FE 850C      LDD	R16,Y+12
    03FF 0E00      ADD	R0,R16
    0400 8E08      STD	Y+24,R0
(0508)             y1 += addy;
    0401 8C0A      LDD	R0,Y+26
    0402 850D      LDD	R16,Y+13
    0403 0E00      ADD	R0,R16
    0404 8E0A      STD	Y+26,R0
    0405 840B      LDD	R0,Y+11
    0406 9403      INC	R0
    0407 860B      STD	Y+11,R0
    0408 842B      LDD	R2,Y+11
    0409 2433      CLR	R3
    040A 14E2      CP	R14,R2
    040B 04F3      CPC	R15,R3
    040C F00C      BLT	0x040E
    040D CF95      RJMP	0x03A3
(0509)          }
(0510)       }
(0511)    }
    040E C07C      RJMP	0x048B
(0512)    else
(0513)    {
(0514)       P = 2*dx - dy;
    040F E002      LDI	R16,2
    0410 E010      LDI	R17,0
    0411 0197      MOVW	R18,R14
    0412 940E092F  CALL	empy16s
    0414 0118      MOVW	R2,R16
    0415 1A26      SUB	R2,R22
    0416 0A37      SBC	R3,R23
    0417 823E      STD	Y+6,R3
    0418 822D      STD	Y+5,R2
(0515)       diff = P - dy;
    0419 1A26      SUB	R2,R22
    041A 0A37      SBC	R3,R23
    041B 8638      STD	Y+8,R3
    041C 822F      STD	Y+7,R2
(0516) 
(0517)       for(i=0; i<=dy; ++i)
    041D 2400      CLR	R0
    041E 860B      STD	Y+11,R0
    041F C065      RJMP	0x0485
(0518)       {
(0519)          if(P < 0)
    0420 818D      LDD	R24,Y+5
    0421 819E      LDD	R25,Y+6
    0422 3080      CPI	R24,0
    0423 E0E0      LDI	R30,0
    0424 079E      CPC	R25,R30
    0425 F484      BGE	0x0436
(0520)          {
(0521)             P  += 2*dx;
    0426 E002      LDI	R16,2
    0427 E010      LDI	R17,0
    0428 0197      MOVW	R18,R14
    0429 940E092F  CALL	empy16s
    042B 802D      LDD	R2,Y+5
    042C 803E      LDD	R3,Y+6
    042D 0E20      ADD	R2,R16
    042E 1E31      ADC	R3,R17
    042F 823E      STD	Y+6,R3
    0430 822D      STD	Y+5,R2
(0522)             y1 += addy;
    0431 8C0A      LDD	R0,Y+26
    0432 850D      LDD	R16,Y+13
    0433 0E00      ADD	R0,R16
    0434 8E0A      STD	Y+26,R0
(0523)          }
    0435 C010      RJMP	0x0446
(0524)          else
(0525)          {
(0526)             P  += diff;
    0436 802F      LDD	R2,Y+7
    0437 8438      LDD	R3,Y+8
    0438 804D      LDD	R4,Y+5
    0439 805E      LDD	R5,Y+6
    043A 0C42      ADD	R4,R2
    043B 1C53      ADC	R5,R3
    043C 825E      STD	Y+6,R5
    043D 824D      STD	Y+5,R4
(0527)             x1 += addx;
    043E 8C08      LDD	R0,Y+24
    043F 850C      LDD	R16,Y+12
    0440 0E00      ADD	R0,R16
    0441 8E08      STD	Y+24,R0
(0528)             y1 += addy;
    0442 8C0A      LDD	R0,Y+26
    0443 850D      LDD	R16,Y+13
    0444 0E00      ADD	R0,R16
    0445 8E0A      STD	Y+26,R0
(0529)          }
(0530)          for(j=-half_width; j<half_width+width%2; ++j)
    0446 2D4C      MOV	R20,R12
    0447 9541      NEG	R20
    0448 C031      RJMP	0x047A
(0531)          {
(0532)             #ifdef LARGE_LCD
(0533)             int temp;
(0534)             #else
(0535)             char temp;
(0536)             #endif
(0537) 
(0538)             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed
    0449 2E24      MOV	R2,R20
    044A 2433      CLR	R3
    044B FC27      SBRC	R2,7
    044C 9430      COM	R3
    044D 8D2A      LDD	R18,Y+26
    044E 2733      CLR	R19
    044F 0D22      ADD	R18,R2
    0450 1D33      ADC	R19,R3
    0451 018B      MOVW	R16,R22
    0452 940E092F  CALL	empy16s
    0454 0118      MOVW	R2,R16
    0455 8D28      LDD	R18,Y+24
    0456 2733      CLR	R19
    0457 0187      MOVW	R16,R14
    0458 940E092F  CALL	empy16s
    045A 2EA0      MOV	R10,R16
    045B 0CA2      ADD	R10,R2
    045C 1CB3      ADC	R11,R3
(0539)             if(temp+c1 >= 0 && temp+c2 <=0)
    045D 8029      LDD	R2,Y+1
    045E 803A      LDD	R3,Y+2
    045F 2D8A      MOV	R24,R10
    0460 2799      CLR	R25
    0461 0D82      ADD	R24,R2
    0462 1D93      ADC	R25,R3
    0463 3080      CPI	R24,0
    0464 E0E0      LDI	R30,0
    0465 079E      CPC	R25,R30
    0466 F094      BLT	0x0479
    0467 802B      LDD	R2,Y+3
    0468 803C      LDD	R3,Y+4
    0469 2C4A      MOV	R4,R10
    046A 2455      CLR	R5
    046B 0C42      ADD	R4,R2
    046C 1C53      ADC	R5,R3
    046D 2422      CLR	R2
    046E 2433      CLR	R3
    046F 1424      CP	R2,R4
    0470 0435      CPC	R3,R5
    0471 F03C      BLT	0x0479
(0540)                glcd_pixel(x1+j, y1, color);
    0472 A00A      LDD	R0,Y+34
    0473 8208      STD	Y+0,R0
    0474 8D2A      LDD	R18,Y+26
    0475 8D08      LDD	R16,Y+24
    0476 0F04      ADD	R16,R20
    0477 940E0769  CALL	_glcd_pixel
    0479 9543      INC	R20
    047A E012      LDI	R17,2
    047B A108      LDD	R16,Y+32
    047C 940E0917  CALL	mod8u
    047E 2C2C      MOV	R2,R12
    047F 0E20      ADD	R2,R16
    0480 1542      CP	R20,R2
    0481 F238      BCS	0x0449
    0482 840B      LDD	R0,Y+11
    0483 9403      INC	R0
    0484 860B      STD	Y+11,R0
    0485 842B      LDD	R2,Y+11
    0486 2433      CLR	R3
    0487 1562      CP	R22,R2
    0488 0573      CPC	R23,R3
    0489 F00C      BLT	0x048B
    048A CF95      RJMP	0x0420
(0541)          }
(0542)       }
(0543)    }
    048B 962E      ADIW	R28,0xE
    048C 940E0948  CALL	pop_gset5
    048E 9624      ADIW	R28,4
    048F 9508      RET
_glcd_circle:
  P                    --> R20
  b                    --> R22
  a                    --> R10
  color                --> R12
  fill                 --> R14
  radius               --> Y+19
  y                    --> Y+17
  x                    --> Y+15
    0490 940E08D8  CALL	push_arg4
    0492 940E094B  CALL	push_gset5
    0494 9725      SBIW	R28,5
    0495 88ED      LDD	R14,Y+21
    0496 88CF      LDD	R12,Y+23
(0544) }
(0545) 
(0546) 
(0547) /////////////////////////////////////////////////////////////////////////
(0548) // Purpose:       Draw a circle on a graphic LCD
(0549) // Inputs:        (x,y) - the center of the circle
(0550) //                radius - the radius of the circle
(0551) //                fill - YES or NO
(0552) //                color - ON or OFF
(0553) /////////////////////////////////////////////////////////////////////////
(0554) //#ifdef LARGE_LCD
(0555) //void glcd_circle(int x, int y, int radius, char fill, char color)
(0556) //#else
(0557) void glcd_circle(char x, char y, char radius, char fill, char color)
(0558) //#endif
(0559) {
(0560)    #ifdef LARGE_LCD
(0561)    signed int a, b, P;
(0562)    #else
(0563)    signed char  a, b, P;
(0564)    #endif
(0565) 
(0566)    a = 0;
    0497 24AA      CLR	R10
(0567)    b = radius;
    0498 896B      LDD	R22,Y+19
(0568)    P = 1 - radius;
    0499 E041      LDI	R20,1
    049A 2E06      MOV	R0,R22
    049B 1B46      SUB	R20,R22
(0569) 
(0570)    do
(0571)    {
(0572)       if(fill==1)
    049C 2D8E      MOV	R24,R14
    049D 3081      CPI	R24,1
    049E F569      BNE	0x04CC
(0573)       {
(0574)          glcd_line(x-a, y+b, x+a, y+b, color);
    049F 82CC      STD	Y+4,R12
    04A0 8829      LDD	R2,Y+17
    04A1 0E26      ADD	R2,R22
    04A2 822A      STD	Y+2,R2
    04A3 844F      LDD	R4,Y+15
    04A4 0C4A      ADD	R4,R10
    04A5 8248      STD	Y+0,R4
    04A6 2D22      MOV	R18,R2
    04A7 850F      LDD	R16,Y+15
    04A8 190A      SUB	R16,R10
    04A9 DD8A      RCALL	_glcd_line
(0575)          glcd_line(x-a, y-b, x+a, y-b, color);
    04AA 82CC      STD	Y+4,R12
    04AB 8829      LDD	R2,Y+17
    04AC 1A26      SUB	R2,R22
    04AD 822A      STD	Y+2,R2
    04AE 844F      LDD	R4,Y+15
    04AF 0C4A      ADD	R4,R10
    04B0 8248      STD	Y+0,R4
    04B1 2D22      MOV	R18,R2
    04B2 850F      LDD	R16,Y+15
    04B3 190A      SUB	R16,R10
    04B4 DD7F      RCALL	_glcd_line
(0576)          glcd_line(x-b, y+a, x+b, y+a, color);
    04B5 82CC      STD	Y+4,R12
    04B6 8829      LDD	R2,Y+17
    04B7 0C2A      ADD	R2,R10
    04B8 822A      STD	Y+2,R2
    04B9 844F      LDD	R4,Y+15
    04BA 0E46      ADD	R4,R22
    04BB 8248      STD	Y+0,R4
    04BC 2D22      MOV	R18,R2
    04BD 850F      LDD	R16,Y+15
    04BE 1B06      SUB	R16,R22
    04BF DD74      RCALL	_glcd_line
(0577)          glcd_line(x-b, y-a, x+b, y-a, color);
    04C0 82CC      STD	Y+4,R12
    04C1 8829      LDD	R2,Y+17
    04C2 182A      SUB	R2,R10
    04C3 822A      STD	Y+2,R2
    04C4 844F      LDD	R4,Y+15
    04C5 0E46      ADD	R4,R22
    04C6 8248      STD	Y+0,R4
    04C7 2D22      MOV	R18,R2
    04C8 850F      LDD	R16,Y+15
    04C9 1B06      SUB	R16,R22
    04CA DD69      RCALL	_glcd_line
(0578)       }
    04CB C040      RJMP	0x050C
(0579)       else
(0580)       {
(0581)          glcd_pixel(a+x, b+y, color);
    04CC 82C8      STD	Y+0,R12
    04CD 2F26      MOV	R18,R22
    04CE 8809      LDD	R0,Y+17
    04CF 0D20      ADD	R18,R0
    04D0 2D0A      MOV	R16,R10
    04D1 840F      LDD	R0,Y+15
    04D2 0D00      ADD	R16,R0
    04D3 940E0769  CALL	_glcd_pixel
(0582)          glcd_pixel(b+x, a+y, color);
    04D5 82C8      STD	Y+0,R12
    04D6 2D2A      MOV	R18,R10
    04D7 8809      LDD	R0,Y+17
    04D8 0D20      ADD	R18,R0
    04D9 2F06      MOV	R16,R22
    04DA 840F      LDD	R0,Y+15
    04DB 0D00      ADD	R16,R0
    04DC 940E0769  CALL	_glcd_pixel
(0583)          glcd_pixel(x-a, b+y, color);
    04DE 82C8      STD	Y+0,R12
    04DF 2F26      MOV	R18,R22
    04E0 8809      LDD	R0,Y+17
    04E1 0D20      ADD	R18,R0
    04E2 850F      LDD	R16,Y+15
    04E3 190A      SUB	R16,R10
    04E4 940E0769  CALL	_glcd_pixel
(0584)          glcd_pixel(x-b, a+y, color);
    04E6 82C8      STD	Y+0,R12
    04E7 2D2A      MOV	R18,R10
    04E8 8809      LDD	R0,Y+17
    04E9 0D20      ADD	R18,R0
    04EA 850F      LDD	R16,Y+15
    04EB 1B06      SUB	R16,R22
    04EC 940E0769  CALL	_glcd_pixel
(0585)          glcd_pixel(b+x, y-a, color);
    04EE 82C8      STD	Y+0,R12
    04EF 8929      LDD	R18,Y+17
    04F0 192A      SUB	R18,R10
    04F1 2F06      MOV	R16,R22
    04F2 840F      LDD	R0,Y+15
    04F3 0D00      ADD	R16,R0
    04F4 940E0769  CALL	_glcd_pixel
(0586)          glcd_pixel(a+x, y-b, color);
    04F6 82C8      STD	Y+0,R12
    04F7 8929      LDD	R18,Y+17
    04F8 1B26      SUB	R18,R22
    04F9 2D0A      MOV	R16,R10
    04FA 840F      LDD	R0,Y+15
    04FB 0D00      ADD	R16,R0
    04FC 940E0769  CALL	_glcd_pixel
(0587)          glcd_pixel(x-a, y-b, color);
    04FE 82C8      STD	Y+0,R12
    04FF 8929      LDD	R18,Y+17
    0500 1B26      SUB	R18,R22
    0501 850F      LDD	R16,Y+15
    0502 190A      SUB	R16,R10
    0503 940E0769  CALL	_glcd_pixel
(0588)          glcd_pixel(x-b, y-a, color);
    0505 82C8      STD	Y+0,R12
    0506 8929      LDD	R18,Y+17
    0507 192A      SUB	R18,R10
    0508 850F      LDD	R16,Y+15
    0509 1B06      SUB	R16,R22
    050A 940E0769  CALL	_glcd_pixel
(0589)       }
(0590) 
(0591)       if(P < 0)
    050C 3040      CPI	R20,0
    050D F4B4      BGE	0x0524
(0592)          P += 3 + 2 * a++;
    050E 2C2A      MOV	R2,R10
    050F 2433      CLR	R3
    0510 FC27      SBRC	R2,7
    0511 9430      COM	R3
    0512 2D82      MOV	R24,R2
    0513 5F8F      SUBI	R24,0xFF
    0514 2EA8      MOV	R10,R24
    0515 E002      LDI	R16,2
    0516 E010      LDI	R17,0
    0517 0191      MOVW	R18,R2
    0518 940E092F  CALL	empy16s
    051A 01C8      MOVW	R24,R16
    051B 9603      ADIW	R24,3
    051C 2E24      MOV	R2,R20
    051D 2433      CLR	R3
    051E FC27      SBRC	R2,7
    051F 9430      COM	R3
    0520 0E28      ADD	R2,R24
    0521 1E39      ADC	R3,R25
    0522 2D42      MOV	R20,R2
    0523 C020      RJMP	0x0544
(0593)       else
(0594)          P += 5 + 2 * (a++ - b--);
    0524 2C2A      MOV	R2,R10
    0525 2433      CLR	R3
    0526 FC27      SBRC	R2,7
    0527 9430      COM	R3
    0528 2D82      MOV	R24,R2
    0529 5F8F      SUBI	R24,0xFF
    052A 2EA8      MOV	R10,R24
    052B 2E46      MOV	R4,R22
    052C 2455      CLR	R5
    052D FC47      SBRC	R4,7
    052E 9450      COM	R5
    052F 2D64      MOV	R22,R4
    0530 5061      SUBI	R22,1
    0531 2D22      MOV	R18,R2
    0532 2733      CLR	R19
    0533 FD27      SBRC	R18,7
    0534 9530      COM	R19
    0535 1924      SUB	R18,R4
    0536 0935      SBC	R19,R5
    0537 E002      LDI	R16,2
    0538 E010      LDI	R17,0
    0539 940E092F  CALL	empy16s
    053B 01C8      MOVW	R24,R16
    053C 9605      ADIW	R24,5
    053D 2E24      MOV	R2,R20
    053E 2433      CLR	R3
    053F FC27      SBRC	R2,7
    0540 9430      COM	R3
    0541 0E28      ADD	R2,R24
    0542 1E39      ADC	R3,R25
    0543 2D42      MOV	R20,R2
(0595)     } while(a <= b);
    0544 156A      CP	R22,R10
    0545 F00C      BLT	0x0547
    0546 CF55      RJMP	0x049C
    0547 9625      ADIW	R28,5
    0548 940E0948  CALL	pop_gset5
    054A 9624      ADIW	R28,4
    054B 9508      RET
_glcd_text35:
  i                    --> R20
  l                    --> R14
  pixelData            --> Y+1
  j                    --> R10
  k                    --> R12
  color                --> R22
  textptr              --> Y+20
  y                    --> Y+18
  x                    --> Y+16
    054C 940E08D8  CALL	push_arg4
    054E 940E094B  CALL	push_gset5
    0550 9726      SBIW	R28,6
    0551 896E      LDD	R22,Y+22
(0596) }
(0597) 
(0598) 
(0599) void glcd_text35(char x, char y, char* textptr, char color)
(0600) {
(0601)    int i, j, k, l;                           // Loop counters
(0602)    char pixelData[5];                     // Stores character data
(0603) 
(0604)    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string
    0552 2744      CLR	R20
    0553 2755      CLR	R21
    0554 C082      RJMP	0x05D7
(0605)    {
(0606)       if((textptr[i] >= ' ') && (textptr[i] <= '~'))
    0555 01FA      MOVW	R30,R20
    0556 880C      LDD	R0,Y+20
    0557 881D      LDD	R1,Y+21
    0558 0DE0      ADD	R30,R0
    0559 1DF1      ADC	R31,R1
    055A 8020      LDD	R2,Z+0
    055B 2433      CLR	R3
    055C 2D82      MOV	R24,R2
    055D 3280      CPI	R24,0x20
    055E F120      BCS	0x0583
    055F E78E      LDI	R24,0x7E
    0560 1582      CP	R24,R2
    0561 F108      BCS	0x0583
(0607)          for(l=0;l<5;l++)
    0562 24EE      CLR	R14
    0563 24FF      CLR	R15
(0608) 		   pixelData[l]=TEXT35[textptr[i]-' '][l];
    0564 01FA      MOVW	R30,R20
    0565 880C      LDD	R0,Y+20
    0566 881D      LDD	R1,Y+21
    0567 0DE0      ADD	R30,R0
    0568 1DF1      ADC	R31,R1
    0569 8020      LDD	R2,Z+0
    056A E085      LDI	R24,5
    056B 9D82      MUL	R24,R2
    056C 0110      MOVW	R2,R0
    056D EB84      LDI	R24,0xB4
    056E EF9F      LDI	R25,0xFF
    056F 0E28      ADD	R2,R24
    0570 1E39      ADC	R3,R25
    0571 01F7      MOVW	R30,R14
    0572 0DE2      ADD	R30,R2
    0573 1DF3      ADC	R31,R3
    0574 91E4      LPM	R30,0(Z)
    0575 01CE      MOVW	R24,R28
    0576 9601      ADIW	R24,1
    0577 01D7      MOVW	R26,R14
    0578 0FA8      ADD	R26,R24
    0579 1FB9      ADC	R27,R25
    057A 93EC      ST	R30,0(X)
    057B 01C7      MOVW	R24,R14
    057C 9601      ADIW	R24,1
    057D 017C      MOVW	R14,R24
    057E 3085      CPI	R24,5
    057F E0E0      LDI	R30,0
    0580 079E      CPC	R25,R30
    0581 F314      BLT	0x0564
    0582 C015      RJMP	0x0598
(0609)       else
(0610)          for(l=0;l<5;l++)
    0583 24EE      CLR	R14
    0584 24FF      CLR	R15
(0611) 		   pixelData[l]=TEXT35[0][l]; // Default to space
    0585 E584      LDI	R24,0x54
    0586 E090      LDI	R25,0
    0587 01F7      MOVW	R30,R14
    0588 0FE8      ADD	R30,R24
    0589 1FF9      ADC	R31,R25
    058A 91E4      LPM	R30,0(Z)
    058B 01CE      MOVW	R24,R28
    058C 9601      ADIW	R24,1
    058D 01D7      MOVW	R26,R14
    058E 0FA8      ADD	R26,R24
    058F 1FB9      ADC	R27,R25
    0590 93EC      ST	R30,0(X)
    0591 01C7      MOVW	R24,R14
    0592 9601      ADIW	R24,1
    0593 017C      MOVW	R14,R24
    0594 3085      CPI	R24,5
    0595 E0E0      LDI	R30,0
    0596 079E      CPC	R25,R30
    0597 F36C      BLT	0x0585
(0612) 
(0613)       if(x+3 >= GLCD_WIDTH)          // Performs character wrapping
    0598 8988      LDD	R24,Y+16
    0599 5F8D      SUBI	R24,0xFD
    059A 3880      CPI	R24,0x80
    059B F028      BCS	0x05A1
(0614)       {
(0615)          x = 0;                           // Set x at far left position
    059C 2400      CLR	R0
    059D 8A08      STD	Y+16,R0
(0616)          y += 5 + 1;                      // Set y at next position down
    059E 898A      LDD	R24,Y+18
    059F 5F8A      SUBI	R24,0xFA
    05A0 8B8A      STD	Y+18,R24
(0617)       }
(0618)       for(j=3; j>0; j--, x++)             // Loop through character byte data
    05A1 E083      LDI	R24,3
    05A2 E090      LDI	R25,0
    05A3 015C      MOVW	R10,R24
(0619)       {
(0620)          for(k=0; k<5; k++)               // Loop through the vertical pixels
    05A4 24CC      CLR	R12
    05A5 24DD      CLR	R13
(0621)          {
(0622)             if(CHKBIT(pixelData[k], j)) // Check if the pixel should be set
    05A6 E001      LDI	R16,1
    05A7 E010      LDI	R17,0
    05A8 0195      MOVW	R18,R10
    05A9 940E096A  CALL	lsl16
    05AB 01CE      MOVW	R24,R28
    05AC 9601      ADIW	R24,1
    05AD 01F6      MOVW	R30,R12
    05AE 0FE8      ADD	R30,R24
    05AF 1FF9      ADC	R31,R25
    05B0 8020      LDD	R2,Z+0
    05B1 2433      CLR	R3
    05B2 2220      AND	R2,R16
    05B3 2231      AND	R3,R17
    05B4 2022      TST	R2
    05B5 F411      BNE	0x05B8
    05B6 2033      TST	R3
    05B7 F041      BEQ	0x05C0
(0623)             {
(0624)                glcd_pixel(x, y+k, color); // Draws the pixel
    05B8 8368      STD	Y+0,R22
    05B9 892A      LDD	R18,Y+18
    05BA 2733      CLR	R19
    05BB 0D2C      ADD	R18,R12
    05BC 1D3D      ADC	R19,R13
    05BD 8908      LDD	R16,Y+16
    05BE 940E0769  CALL	_glcd_pixel
    05C0 01C6      MOVW	R24,R12
    05C1 9601      ADIW	R24,1
    05C2 016C      MOVW	R12,R24
    05C3 3085      CPI	R24,5
    05C4 E0E0      LDI	R30,0
    05C5 079E      CPC	R25,R30
    05C6 F2FC      BLT	0x05A6
    05C7 01C5      MOVW	R24,R10
    05C8 9701      SBIW	R24,1
    05C9 015C      MOVW	R10,R24
    05CA 8808      LDD	R0,Y+16
    05CB 9403      INC	R0
    05CC 8A08      STD	Y+16,R0
    05CD 2422      CLR	R2
    05CE 2433      CLR	R3
    05CF 1628      CP	R2,R24
    05D0 0639      CPC	R3,R25
    05D1 F294      BLT	0x05A4
    05D2 5F4F      SUBI	R20,0xFF
    05D3 4F5F      SBCI	R21,0xFF
    05D4 8808      LDD	R0,Y+16
    05D5 9403      INC	R0
    05D6 8A08      STD	Y+16,R0
    05D7 01FA      MOVW	R30,R20
    05D8 880C      LDD	R0,Y+20
    05D9 881D      LDD	R1,Y+21
    05DA 0DE0      ADD	R30,R0
    05DB 1DF1      ADC	R31,R1
    05DC 8020      LDD	R2,Z+0
    05DD 2022      TST	R2
    05DE F009      BEQ	0x05E0
    05DF CF75      RJMP	0x0555
    05E0 9626      ADIW	R28,6
    05E1 940E0948  CALL	pop_gset5
    05E3 9624      ADIW	R28,4
    05E4 9508      RET
_glcd_text57:
  n                    --> R14
  pixelData            --> Y+1
  j                    --> R22
  k                    --> R12
  l                    --> R20
  m                    --> R10
  color                --> Y+26
  size                 --> Y+24
  textptr              --> Y+22
  y                    --> Y+20
  x                    --> Y+18
    05E5 940E08D8  CALL	push_arg4
    05E7 940E094B  CALL	push_gset5
    05E9 9728      SBIW	R28,0x8
(0625)             }
(0626)          }
(0627)       }
(0628)    }
(0629) }
(0630) 
(0631) /////////////////////////////////////////////////////////////////////////
(0632) // Purpose:       Write text on a graphic LCD
(0633) // Inputs:        (x,y) - The upper left coordinate of the first letter
(0634) //                textptr - A pointer to an array of text to display
(0635) //                size - The size of the text: 1 = 5x7, 2 = 10x14, ...
(0636) //                color - ON or OFF
(0637) /////////////////////////////////////////////////////////////////////////
(0638) void glcd_text57(char x, char y, char* textptr, char size, char color)
(0639) {
(0640)    char j, k, l, m, n;                       // Loop counters
(0641)    char pixelData[5];                     // Stores character data
(0642) 
(0643)    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string
    05EA C0C1      RJMP	0x06AC
(0644)    {
(0645)       if(*textptr < 'S') // Checks if the letter is in the first font array
    05EB 89EE      LDD	R30,Y+22
    05EC 89FF      LDD	R31,Y+23
    05ED 8180      LDD	R24,Z+0
    05EE 3583      CPI	R24,0x53
    05EF F4E8      BCC	0x060D
(0646)          for(n=0;n<5;n++)pixelData[n]=FONT[*textptr - ' '][n];
    05F0 24EE      CLR	R14
    05F1 C017      RJMP	0x0609
    05F2 89EE      LDD	R30,Y+22
    05F3 89FF      LDD	R31,Y+23
    05F4 8020      LDD	R2,Z+0
    05F5 E085      LDI	R24,5
    05F6 9D82      MUL	R24,R2
    05F7 0110      MOVW	R2,R0
    05F8 E984      LDI	R24,0x94
    05F9 E091      LDI	R25,1
    05FA 0E28      ADD	R2,R24
    05FB 1E39      ADC	R3,R25
    05FC 2DEE      MOV	R30,R14
    05FD 27FF      CLR	R31
    05FE 0DE2      ADD	R30,R2
    05FF 1DF3      ADC	R31,R3
    0600 91E4      LPM	R30,0(Z)
    0601 01CE      MOVW	R24,R28
    0602 9601      ADIW	R24,1
    0603 2DAE      MOV	R26,R14
    0604 27BB      CLR	R27
    0605 0FA8      ADD	R26,R24
    0606 1FB9      ADC	R27,R25
    0607 93EC      ST	R30,0(X)
    0608 94E3      INC	R14
    0609 2D8E      MOV	R24,R14
    060A 3085      CPI	R24,5
    060B F330      BCS	0x05F2
    060C C037      RJMP	0x0644
(0647)       else if(*textptr <= '~') // Check if the letter is in the second font array
    060D E78E      LDI	R24,0x7E
    060E 89EE      LDD	R30,Y+22
    060F 89FF      LDD	R31,Y+23
    0610 8020      LDD	R2,Z+0
    0611 1582      CP	R24,R2
    0612 F0E8      BCS	0x0630
(0648)          for(n=0;n<5;n++)pixelData[n]=FONT2[*textptr - 'S'][n];
    0613 24EE      CLR	R14
    0614 C017      RJMP	0x062C
    0615 89EE      LDD	R30,Y+22
    0616 89FF      LDD	R31,Y+23
    0617 8020      LDD	R2,Z+0
    0618 E085      LDI	R24,5
    0619 9D82      MUL	R24,R2
    061A 0110      MOVW	R2,R0
    061B E984      LDI	R24,0x94
    061C E091      LDI	R25,1
    061D 0E28      ADD	R2,R24
    061E 1E39      ADC	R3,R25
    061F 2DEE      MOV	R30,R14
    0620 27FF      CLR	R31
    0621 0DE2      ADD	R30,R2
    0622 1DF3      ADC	R31,R3
    0623 91E4      LPM	R30,0(Z)
    0624 01CE      MOVW	R24,R28
    0625 9601      ADIW	R24,1
    0626 2DAE      MOV	R26,R14
    0627 27BB      CLR	R27
    0628 0FA8      ADD	R26,R24
    0629 1FB9      ADC	R27,R25
    062A 93EC      ST	R30,0(X)
    062B 94E3      INC	R14
    062C 2D8E      MOV	R24,R14
    062D 3085      CPI	R24,5
    062E F330      BCS	0x0615
    062F C014      RJMP	0x0644
(0649)       else
(0650)          for(n=0;n<5;n++)pixelData[n]=FONT[0][n];   // Default to space
    0630 24EE      CLR	R14
    0631 C00F      RJMP	0x0641
    0632 E384      LDI	R24,0x34
    0633 E092      LDI	R25,2
    0634 2DEE      MOV	R30,R14
    0635 27FF      CLR	R31
    0636 0FE8      ADD	R30,R24
    0637 1FF9      ADC	R31,R25
    0638 91E4      LPM	R30,0(Z)
    0639 01CE      MOVW	R24,R28
    063A 9601      ADIW	R24,1
    063B 2DAE      MOV	R26,R14
    063C 27BB      CLR	R27
    063D 0FA8      ADD	R26,R24
    063E 1FB9      ADC	R27,R25
    063F 93EC      ST	R30,0(X)
    0640 94E3      INC	R14
    0641 2D8E      MOV	R24,R14
    0642 3085      CPI	R24,5
    0643 F370      BCS	0x0632
(0651) 
(0652)       // Handles newline and carriage returns
(0653)       switch(*textptr)
    0644 89EE      LDD	R30,Y+22
    0645 89FF      LDD	R31,Y+23
    0646 8020      LDD	R2,Z+0
    0647 2433      CLR	R3
    0648 823F      STD	Y+7,R3
    0649 822E      STD	Y+6,R2
    064A 01C1      MOVW	R24,R2
    064B 308A      CPI	R24,0xA
    064C E0E0      LDI	R30,0
    064D 079E      CPC	R25,R30
    064E F029      BEQ	0x0654
    064F 308D      CPI	R24,0xD
    0650 E0E0      LDI	R30,0
    0651 079E      CPC	R25,R30
    0652 F051      BEQ	0x065D
    0653 C00C      RJMP	0x0660
(0654)       {
(0655)          case '\n':
(0656)             y += 7*size + 1;
    0654 E087      LDI	R24,7
    0655 8C08      LDD	R0,Y+24
    0656 9D80      MUL	R24,R0
    0657 2D80      MOV	R24,R0
    0658 5F8F      SUBI	R24,0xFF
    0659 880C      LDD	R0,Y+20
    065A 0E08      ADD	R0,R24
    065B 8A0C      STD	Y+20,R0
(0657)             continue;
    065C C047      RJMP	0x06A4
(0658)          case '\r':
(0659)             x = 0;
    065D 2400      CLR	R0
    065E 8A0A      STD	Y+18,R0
(0660)             continue;
    065F C044      RJMP	0x06A4
(0661)       }
(0662) 
(0663)       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping
    0660 E085      LDI	R24,5
    0661 8C08      LDD	R0,Y+24
    0662 9D80      MUL	R24,R0
    0663 898A      LDD	R24,Y+18
    0664 0D80      ADD	R24,R0
    0665 3880      CPI	R24,0x80
    0666 F050      BCS	0x0671
(0664)       {
(0665)          x = 0;                           // Set x at far left position
    0667 2400      CLR	R0
    0668 8A0A      STD	Y+18,R0
(0666)          y += 7*size + 1;                 // Set y at next position down
    0669 E087      LDI	R24,7
    066A 8C08      LDD	R0,Y+24
    066B 9D80      MUL	R24,R0
    066C 2D80      MOV	R24,R0
    066D 5F8F      SUBI	R24,0xFF
    066E 880C      LDD	R0,Y+20
    066F 0E08      ADD	R0,R24
    0670 8A0C      STD	Y+20,R0
(0667)       }
(0668)       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data
    0671 2766      CLR	R22
    0672 C02F      RJMP	0x06A2
(0669)       {
(0670)          for(k=0; k < 7; ++k)             // Loop through the vertical pixels
    0673 24CC      CLR	R12
    0674 C025      RJMP	0x069A
(0671)          {
(0672)             if(CHKBIT(pixelData[j], k)) // Check if the pixel should be set
    0675 E001      LDI	R16,1
    0676 2D1C      MOV	R17,R12
    0677 940E0971  CALL	lsl8
    0679 01CE      MOVW	R24,R28
    067A 9601      ADIW	R24,1
    067B 2FE6      MOV	R30,R22
    067C 27FF      CLR	R31
    067D 0FE8      ADD	R30,R24
    067E 1FF9      ADC	R31,R25
    067F 8020      LDD	R2,Z+0
    0680 2220      AND	R2,R16
    0681 F0B9      BEQ	0x0699
(0673)             {
(0674)                for(l=0; l < size; ++l)    // These two loops change the
    0682 2744      CLR	R20
    0683 C012      RJMP	0x0696
(0675)                {                          // character's size
(0676)                   for(m=0; m < size; ++m)
    0684 24AA      CLR	R10
    0685 C00C      RJMP	0x0692
(0677)                   {
(0678)                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
    0686 8C0A      LDD	R0,Y+26
    0687 8208      STD	Y+0,R0
    0688 8C08      LDD	R0,Y+24
    0689 9CC0      MUL	R12,R0
    068A 892C      LDD	R18,Y+20
    068B 0D20      ADD	R18,R0
    068C 0F24      ADD	R18,R20
    068D 890A      LDD	R16,Y+18
    068E 0D0A      ADD	R16,R10
    068F 940E0769  CALL	_glcd_pixel
    0691 94A3      INC	R10
    0692 8C08      LDD	R0,Y+24
    0693 14A0      CP	R10,R0
    0694 F388      BCS	0x0686
    0695 9543      INC	R20
    0696 8C08      LDD	R0,Y+24
    0697 1540      CP	R20,R0
    0698 F358      BCS	0x0684
    0699 94C3      INC	R12
    069A 2D8C      MOV	R24,R12
    069B 3087      CPI	R24,7
    069C F2C0      BCS	0x0675
    069D 9563      INC	R22
    069E 880A      LDD	R0,Y+18
    069F 8D08      LDD	R16,Y+24
    06A0 0E00      ADD	R0,R16
    06A1 8A0A      STD	Y+18,R0
    06A2 3065      CPI	R22,5
    06A3 F278      BCS	0x0673
    06A4 898E      LDD	R24,Y+22
    06A5 899F      LDD	R25,Y+23
    06A6 9601      ADIW	R24,1
    06A7 8B9F      STD	Y+23,R25
    06A8 8B8E      STD	Y+22,R24
    06A9 880A      LDD	R0,Y+18
    06AA 9403      INC	R0
    06AB 8A0A      STD	Y+18,R0
    06AC 89EE      LDD	R30,Y+22
    06AD 89FF      LDD	R31,Y+23
    06AE 8020      LDD	R2,Z+0
    06AF 2022      TST	R2
    06B0 F009      BEQ	0x06B2
    06B1 CF39      RJMP	0x05EB
    06B2 9628      ADIW	R28,0x8
    06B3 940E0948  CALL	pop_gset5
    06B5 9624      ADIW	R28,4
    06B6 9508      RET
_LCD_DataWrite:
  Num                  --> R20
  Dat                  --> R16
    06B7 940E0953  CALL	push_gset1
FILE: E:\avr\iccavrproject\mzl0512864\mzl05.c
(0001) /////////////////////////////////////////////////////////////////////////
(0002) ////                           mzl05.c                           ////
(0003) ////                                                                 ////
(0004) ////                                                                 ////
(0005) //// LCD Pin connections:  PORTA                                     ////
(0006) //// (These can be changed as needed in the following defines).      ////
(0007) ////  * 0: SDI                                                        ////
(0008) ////  * 1: SCK                                                        ////
(0009) ////  * 2: A0                                                         ////
(0010) ////  * 3: RS                                                        ////
(0011) ////  * 4: CS1                                                       ////
(0012) ////  DATA PORTA                                                     ////
(0013) /////////////////////////////////////////////////////////////////////////
(0014) ////     gnd|VCC|SDI|SCK|A0|RES|CS1,CS11                                                            ////
(0015) ////  glcd_init(mode)                                                ////
(0016) ////     * Must be called before any other function.                 ////
(0017) ////       - mode can be ON or OFF to turn the LCD on or off         ////
(0018) ////                                                                 ////
(0019) ////  glcd_pixel(x,y,color)                                          ////
(0020) ////     * Sets the pixel to the given color.                        ////
(0021) ////       - color can be ON or OFF                                  ////
(0022) ////                                                                 ////
(0023) ////  glcd_fillScreen(color)                                         ////
(0024) ////     * Fills the entire LCD with the given color.                ////
(0025) ////       - color can be ON or OFF                                  ////
(0026) ////                                                                 ////
(0027) ////  glcd_update()                                                  ////
(0028) ////     * Write the display data stored in RAM to the LCD           ////
(0029) ////     * Only available if FAST_GLCD is defined                    ////
(0030) ////                                                                 ////
(0031) /////////////////////////////////////////////////////////////////////////
(0032) ////        (C) Copyright 1996, 2004 Custom Computer Services        ////
(0033) //// This source code may only be used by licensed users of the CCS  ////
(0034) //// C compiler.  This source code may only be distributed to other  ////
(0035) //// licensed users of the CCS C compiler.  No other use,            ////
(0036) //// reproduction or distribution is permitted without written       ////
(0037) //// permission.  Derivative programs created using this software    ////
(0038) //// in object code form are not restricted in any way.              ////
(0039) /////////////////////////////////////////////////////////////////////////
(0040) #include <iom16v.h>
(0041) #include "mzl05.h"
(0042) 
(0043) char glcdhalf;
(0044) 
(0045) /*  lcd port define: connect to PORTA of MEGA16 */
(0046) #define	SDI	 0   
(0047) #define	SCK	 1
(0048) #define	A0	 2
(0049) #define	RES	 3
(0050) #define	CS1	 4
(0051) #define LCD_PORT PORTA
(0052) 
(0053) /******************************************************************** */
(0054) 
(0055) #define SDI_H SETBIT(LCD_PORT,SDI)
(0056) #define SDI_L CLRBIT(LCD_PORT,SDI)
(0057) #define SCK_H SETBIT(LCD_PORT,SCK)    
(0058) #define SCK_L CLRBIT(LCD_PORT,SCK)   
(0059) #define A0_H SETBIT(LCD_PORT,A0)
(0060) #define A0_L CLRBIT(LCD_PORT,A0)
(0061) #define RES_H SETBIT(LCD_PORT,RES)
(0062) #define RES_L CLRBIT(LCD_PORT,RES)
(0063) #define CS1_H SETBIT(LCD_PORT,CS1)
(0064) #define CS1_L CLRBIT(LCD_PORT,CS1)
(0065) 
(0066) #ifndef GLCD_WIDTH
(0067) #define GLCD_WIDTH   128
(0068) #endif
(0069) 
(0070) #ifndef GLCD_HEIGHT
(0071) #define GLCD_HEIGHT      64
(0072) #endif
(0073) 
(0074) #ifndef ON
(0075) #define ON           1
(0076) #endif
(0077) 
(0078) #ifndef OFF
(0079) #define OFF          0
(0080) #endif
(0081) 
(0082) //////////////////////////////////////////////////////////////////////
(0083) 
(0084) 
(0085) char LCD_Buffer[128][4];
(0086) 
(0087) 
(0088) //========================================================================
(0089) // : void LCD_DataWrite(unsigned int Data)
(0090) // : LCDRAM
(0091) // : Data  
(0092) // : 
(0093) // : 
(0094) // :
(0095) //      2007/01/09      First version
(0096) //========================================================================
(0097) void LCD_DataWrite(char Dat)//,_Fill_Dot_LCD
(0098) {
(0099)    char Num;
(0100)    CS1_L;
    06B9 98DC      CBI	0x1B,4
(0101)    A0_H;
    06BA 9ADA      SBI	0x1B,2
(0102)    for(Num=0;Num<8;Num++)
    06BB 2744      CLR	R20
    06BC C009      RJMP	0x06C6
(0103)    {
(0104)       if((Dat&0x80) == 0)   SDI_L;
    06BD FD07      SBRC	R16,7
    06BE C002      RJMP	0x06C1
    06BF 98D8      CBI	0x1B,0
    06C0 C001      RJMP	0x06C2
(0105)       else SDI_H;
    06C1 9AD8      SBI	0x1B,0
(0106)       Dat = Dat << 1;
    06C2 0F00      LSL	R16
(0107)       SCK_L;
    06C3 98D9      CBI	0x1B,1
(0108)       SCK_H;
    06C4 9AD9      SBI	0x1B,1
    06C5 9543      INC	R20
    06C6 3048      CPI	R20,0x8
    06C7 F3A8      BCS	0x06BD
    06C8 940E0956  CALL	pop_gset1
    06CA 9508      RET
_LCD_RegWrite:
  Num                  --> R20
  Command              --> R16
    06CB 940E0953  CALL	push_gset1
(0109)    }
(0110) }
(0111) //========================================================================
(0112) // : void LCD_RegWrite(unsigned char Command)
(0113) // : LCD
(0114) // : Command      byte 
(0115) // : 
(0116) // : 
(0117) // :
(0118) //      2007/01/09      First version
(0119) //========================================================================
(0120) void LCD_RegWrite(char Command)
(0121) {
(0122)    char Num;
(0123)    CS1_L;
    06CD 98DC      CBI	0x1B,4
(0124)    A0_L;
    06CE 98DA      CBI	0x1B,2
(0125)    for(Num=0;Num<8;Num++)
    06CF 2744      CLR	R20
    06D0 C009      RJMP	0x06DA
(0126)    {
(0127)       if((Command&0x80) == 0)   SDI_L;
    06D1 FD07      SBRC	R16,7
    06D2 C002      RJMP	0x06D5
    06D3 98D8      CBI	0x1B,0
    06D4 C001      RJMP	0x06D6
(0128)       else SDI_H;
    06D5 9AD8      SBI	0x1B,0
(0129)       Command = Command << 1;
    06D6 0F00      LSL	R16
(0130)       SCK_L;
    06D7 98D9      CBI	0x1B,1
(0131)       SCK_H;
    06D8 9AD9      SBI	0x1B,1
    06D9 9543      INC	R20
    06DA 3048      CPI	R20,0x8
    06DB F3A8      BCS	0x06D1
    06DC 940E0956  CALL	pop_gset1
    06DE 9508      RET
_LCD_Fill:
  uiTemp               --> R20
  i                    --> R22
  j                    --> R12
  Data                 --> R10
    06DF 940E094D  CALL	push_gset4
    06E1 2EA0      MOV	R10,R16
(0132)    }
(0133) }
(0134) //========================================================================
(0135) // : void LCD_Fill(unsigned int Data)
(0136) // : Data
(0137) // : Data   
(0138) // : 
(0139) // : LCD
(0140) // :
(0141) //      2006/10/15      First version
(0142) //      2007/01/09      V1.2 
(0143) //========================================================================
(0144) void LCD_Fill(char Data)
(0145) {
(0146)    char i,j;
(0147)    char uiTemp;
(0148)    uiTemp = GLCD_HEIGHT;
    06E2 E240      LDI	R20,0x20
(0149)    uiTemp = uiTemp>>3;
    06E3 9546      LSR	R20
    06E4 9546      LSR	R20
    06E5 9546      LSR	R20
(0150)    for(i=0;i<=uiTemp;i++)                        //LCD
    06E6 2766      CLR	R22
    06E7 C010      RJMP	0x06F8
(0151)    {
(0152)       LCD_RegWrite(0xb0+i);
    06E8 2F06      MOV	R16,R22
    06E9 5500      SUBI	R16,0x50
    06EA DFE0      RCALL	_LCD_RegWrite
(0153)       LCD_RegWrite(0x01);
    06EB E001      LDI	R16,1
    06EC DFDE      RCALL	_LCD_RegWrite
(0154)       LCD_RegWrite(0x10);
    06ED E100      LDI	R16,0x10
    06EE DFDC      RCALL	_LCD_RegWrite
(0155)       for(j=0;j<=GLCD_WIDTH;j++)
    06EF 24CC      CLR	R12
    06F0 C003      RJMP	0x06F4
(0156)       {
(0157)          LCD_DataWrite(Data);
    06F1 2D0A      MOV	R16,R10
    06F2 DFC4      RCALL	_LCD_DataWrite
    06F3 94C3      INC	R12
    06F4 E880      LDI	R24,0x80
    06F5 158C      CP	R24,R12
    06F6 F7D0      BCC	0x06F1
    06F7 9563      INC	R22
    06F8 1746      CP	R20,R22
    06F9 F770      BCC	0x06E8
    06FA 940E0945  CALL	pop_gset4
    06FC 9508      RET
(0158)       }
(0159)    }
(0160) }
(0161) //========================================================================
(0162) // : void LCD_Init(void)
(0163) // : LCDLCD
(0164) //       DataSheet
(0165) // :  
(0166) // : 
(0167) // :
(0168) // :
(0169) //      2006/10/15      First version
(0170) //      2007/01/09      V1.2
(0171) //      2007/06/27      V1.21 
(0172) //========================================================================
(0173) 
(0174) 
(0175) // Purpose:       Initialize the LCD.
(0176) //                Call before using any other LCD function.
(0177) // Inputs:        OFF - Turns the LCD off
(0178) //                ON  - Turns the LCD on
(0179) void glcd_init(void)
(0180) {
(0181)    //LCD
(0182) //   delay_us(200);
(0183)    RES_L;
_glcd_init:
    06FD 98DB      CBI	0x1B,3
(0184) //   delay_us(200);
(0185)    RES_H;
    06FE 9ADB      SBI	0x1B,3
(0186) //   delay_us(20);
(0187)    
(0188)    LCD_RegWrite(0xaf); //LCD On
    06FF EA0F      LDI	R16,0xAF
    0700 DFCA      RCALL	_LCD_RegWrite
(0189)    LCD_RegWrite(0x2f); //
    0701 E20F      LDI	R16,0x2F
    0702 DFC8      RCALL	_LCD_RegWrite
(0190)    LCD_RegWrite(0x81); //
    0703 E801      LDI	R16,0x81
    0704 DFC6      RCALL	_LCD_RegWrite
(0191)    LCD_RegWrite(0x28); //0x0000~0x003f
    0705 E208      LDI	R16,0x28
    0706 DFC4      RCALL	_LCD_RegWrite
(0192)    LCD_RegWrite(0x24); //V5 ---27
    0707 E204      LDI	R16,0x24
    0708 DFC2      RCALL	_LCD_RegWrite
(0193)    LCD_RegWrite(0xa1); //LCD a2
    0709 EA01      LDI	R16,0xA1
    070A DFC0      RCALL	_LCD_RegWrite
(0194)    LCD_RegWrite(0xc8); //Com ,
    070B EC08      LDI	R16,0xC8
    070C DFBE      RCALL	_LCD_RegWrite
(0195)    LCD_RegWrite(0xa0); //Segment ,
    070D EA00      LDI	R16,0xA0
    070E DFBC      RCALL	_LCD_RegWrite
(0196)    LCD_RegWrite(0xa4); ///
    070F EA04      LDI	R16,0xA4
    0710 DFBA      RCALL	_LCD_RegWrite
(0197)    LCD_RegWrite(0xa6); //
    0711 EA06      LDI	R16,0xA6
    0712 DFB8      RCALL	_LCD_RegWrite
(0198)    LCD_RegWrite(0xac); //
    0713 EA0C      LDI	R16,0xAC
    0714 DFB6      RCALL	_LCD_RegWrite
(0199)    LCD_RegWrite(0x00); //
    0715 2700      CLR	R16
    0716 DFB4      RCALL	_LCD_RegWrite
(0200)    LCD_RegWrite(0x40 +0); //RAM
    0717 E400      LDI	R16,0x40
    0718 DFB2      RCALL	_LCD_RegWrite
(0201)    LCD_RegWrite(0xe0); //
    0719 EE00      LDI	R16,0xE0
    071A DFB0      RCALL	_LCD_RegWrite
(0202)    ////
(0203)      
(0204)    glcd_fillScreen(OFF);                // Clear the display
    071B 2700      CLR	R16
    071C D0E8      RCALL	_glcd_fillScreen
(0205)    
(0206)    glcd_update();
    071D D001      RCALL	_glcd_update
    071E 9508      RET
_glcd_update:
  uiTemp               --> R20
  i                    --> R22
  j                    --> R10
    071F 940E094F  CALL	push_gset3
(0207)    //delay_ms(10);
(0208) }
(0209) 
(0210) 
(0211) // Purpose:    Update the LCD with data from the display arrays
(0212) 
(0213) void glcd_update()
(0214) {
(0215)    char i,j;
(0216)    char uiTemp;
(0217)    if(glcdhalf==0){
    0721 90200272  LDS	R2,glcdhalf
    0723 2022      TST	R2
    0724 F509      BNE	0x0746
(0218)      //uiTemp = GLCD_HEIGHT;
(0219)      //uiTemp = uiTemp/8/2;
(0220) 	 uiTemp=4;
    0725 E044      LDI	R20,4
(0221)      for(i=0;i<=uiTemp;i++)                        //LCD
    0726 2766      CLR	R22
    0727 C01B      RJMP	0x0743
(0222)      {
(0223)         LCD_RegWrite(0xb0+i);
    0728 2F06      MOV	R16,R22
    0729 5500      SUBI	R16,0x50
    072A DFA0      RCALL	_LCD_RegWrite
(0224)         LCD_RegWrite(0x01);
    072B E001      LDI	R16,1
    072C DF9E      RCALL	_LCD_RegWrite
(0225)         LCD_RegWrite(0x10);
    072D E100      LDI	R16,0x10
    072E DF9C      RCALL	_LCD_RegWrite
(0226)         for(j=0;j<=GLCD_WIDTH;j++)
    072F 24AA      CLR	R10
    0730 C00E      RJMP	0x073F
(0227)         {
(0228)           LCD_DataWrite(LCD_Buffer[j][i]);
    0731 E084      LDI	R24,4
    0732 9D8A      MUL	R24,R10
    0733 0110      MOVW	R2,R0
    0734 E782      LDI	R24,0x72
    0735 E090      LDI	R25,0
    0736 0E28      ADD	R2,R24
    0737 1E39      ADC	R3,R25
    0738 2FE6      MOV	R30,R22
    0739 27FF      CLR	R31
    073A 0DE2      ADD	R30,R2
    073B 1DF3      ADC	R31,R3
    073C 8100      LDD	R16,Z+0
    073D DF79      RCALL	_LCD_DataWrite
    073E 94A3      INC	R10
    073F E880      LDI	R24,0x80
    0740 158A      CP	R24,R10
    0741 F778      BCC	0x0731
    0742 9563      INC	R22
    0743 1746      CP	R20,R22
    0744 F718      BCC	0x0728
(0229)         }
(0230)      }
(0231)    }
    0745 C020      RJMP	0x0766
(0232)    else{
(0233)      //uiTemp = GLCD_HEIGHT;
(0234)      uiTemp = 4;
    0746 E044      LDI	R20,4
(0235)      for(i=0;i<=uiTemp;i++)                        //LCD
    0747 2766      CLR	R22
    0748 C01B      RJMP	0x0764
(0236)      {
(0237)         LCD_RegWrite(0xb0+i+4);
    0749 2F06      MOV	R16,R22
    074A 540C      SUBI	R16,0x4C
    074B DF7F      RCALL	_LCD_RegWrite
(0238)         LCD_RegWrite(0x01);
    074C E001      LDI	R16,1
    074D DF7D      RCALL	_LCD_RegWrite
(0239)         LCD_RegWrite(0x10);
    074E E100      LDI	R16,0x10
    074F DF7B      RCALL	_LCD_RegWrite
(0240)         for(j=0;j<=GLCD_WIDTH;j++)
    0750 24AA      CLR	R10
    0751 C00E      RJMP	0x0760
(0241)         {
(0242)           LCD_DataWrite(LCD_Buffer[j][i]);
    0752 E084      LDI	R24,4
    0753 9D8A      MUL	R24,R10
    0754 0110      MOVW	R2,R0
    0755 E782      LDI	R24,0x72
    0756 E090      LDI	R25,0
    0757 0E28      ADD	R2,R24
    0758 1E39      ADC	R3,R25
    0759 2FE6      MOV	R30,R22
    075A 27FF      CLR	R31
    075B 0DE2      ADD	R30,R2
    075C 1DF3      ADC	R31,R3
    075D 8100      LDD	R16,Z+0
    075E DF58      RCALL	_LCD_DataWrite
    075F 94A3      INC	R10
    0760 E880      LDI	R24,0x80
    0761 158A      CP	R24,R10
    0762 F778      BCC	0x0752
    0763 9563      INC	R22
    0764 1746      CP	R20,R22
    0765 F718      BCC	0x0749
(0243)         }
(0244)      }
(0245)    }	 
    0766 940E0942  CALL	pop_gset3
    0768 9508      RET
_glcd_pixel:
  color                --> Y+4
  y                    --> R20
  x                    --> R22
    0769 940E0951  CALL	push_gset2
    076B 2F42      MOV	R20,R18
    076C 2F60      MOV	R22,R16
(0246) }
(0247) 
(0248) 
(0249) 
(0250) // Purpose:    Turn a pixel on a graphic LCD on or off
(0251) // Inputs:     1) x - the x coordinate of the pixel
(0252) //             2) y - the y coordinate of the pixel
(0253) //             3) color - ON or OFF
(0254) void glcd_pixel(char x, char y, char color)
(0255) {
(0256)    if(glcdhalf==0){
    076D 90200272  LDS	R2,glcdhalf
    076F 2022      TST	R2
    0770 F009      BEQ	0x0772
    0771 C046      RJMP	0x07B8
(0257)      if(y/8<4){
    0772 2F84      MOV	R24,R20
    0773 9586      LSR	R24
    0774 9586      LSR	R24
    0775 9586      LSR	R24
    0776 3084      CPI	R24,4
    0777 F008      BCS	0x0779
    0778 C089      RJMP	0x0802
(0258) 	   if(color==1){
    0779 818C      LDD	R24,Y+4
    077A 3081      CPI	R24,1
    077B F4E9      BNE	0x0799
(0259)           SETBIT(LCD_Buffer[x][y/8], y%8);
    077C E084      LDI	R24,4
    077D 9F86      MUL	R24,R22
    077E 0110      MOVW	R2,R0
    077F E782      LDI	R24,0x72
    0780 E090      LDI	R25,0
    0781 0E28      ADD	R2,R24
    0782 1E39      ADC	R3,R25
    0783 E028      LDI	R18,0x8
    0784 E030      LDI	R19,0
    0785 2F04      MOV	R16,R20
    0786 2711      CLR	R17
    0787 940E08E1  CALL	div16s
    0789 0128      MOVW	R4,R16
    078A 0C42      ADD	R4,R2
    078B 1C53      ADC	R5,R3
    078C E018      LDI	R17,0x8
    078D 2F04      MOV	R16,R20
    078E 940E0917  CALL	mod8u
    0790 2F10      MOV	R17,R16
    0791 E001      LDI	R16,1
    0792 940E0971  CALL	lsl8
    0794 01F2      MOVW	R30,R4
    0795 8020      LDD	R2,Z+0
    0796 2A20      OR	R2,R16
    0797 8220      STD	Z+0,R2
(0260)        }
    0798 C069      RJMP	0x0802
(0261)        else{
(0262)           CLRBIT(LCD_Buffer[x][y/8], y%8);
    0799 E084      LDI	R24,4
    079A 9F86      MUL	R24,R22
    079B 0110      MOVW	R2,R0
    079C E782      LDI	R24,0x72
    079D E090      LDI	R25,0
    079E 0E28      ADD	R2,R24
    079F 1E39      ADC	R3,R25
    07A0 E028      LDI	R18,0x8
    07A1 E030      LDI	R19,0
    07A2 2F04      MOV	R16,R20
    07A3 2711      CLR	R17
    07A4 940E08E1  CALL	div16s
    07A6 0128      MOVW	R4,R16
    07A7 0C42      ADD	R4,R2
    07A8 1C53      ADC	R5,R3
    07A9 E018      LDI	R17,0x8
    07AA 2F04      MOV	R16,R20
    07AB 940E0917  CALL	mod8u
    07AD 2F10      MOV	R17,R16
    07AE E001      LDI	R16,1
    07AF 940E0971  CALL	lsl8
    07B1 2E20      MOV	R2,R16
    07B2 9420      COM	R2
    07B3 01F2      MOVW	R30,R4
    07B4 8030      LDD	R3,Z+0
    07B5 2032      AND	R3,R2
    07B6 8230      STD	Z+0,R3
(0263)        }
(0264) 	 }  
(0265)    }
    07B7 C04A      RJMP	0x0802
(0266)    else{
(0267)      if(y/8>3){
    07B8 E083      LDI	R24,3
    07B9 2E24      MOV	R2,R20
    07BA 9426      LSR	R2
    07BB 9426      LSR	R2
    07BC 9426      LSR	R2
    07BD 1582      CP	R24,R2
    07BE F008      BCS	0x07C0
    07BF C042      RJMP	0x0802
(0268) 	   if(color==1){
    07C0 818C      LDD	R24,Y+4
    07C1 3081      CPI	R24,1
    07C2 F4F9      BNE	0x07E2
(0269)           SETBIT(LCD_Buffer[x][y/8-4], y%8);
    07C3 E084      LDI	R24,4
    07C4 9F86      MUL	R24,R22
    07C5 0110      MOVW	R2,R0
    07C6 E782      LDI	R24,0x72
    07C7 E090      LDI	R25,0
    07C8 0E28      ADD	R2,R24
    07C9 1E39      ADC	R3,R25
    07CA E028      LDI	R18,0x8
    07CB E030      LDI	R19,0
    07CC 2F04      MOV	R16,R20
    07CD 2711      CLR	R17
    07CE 940E08E1  CALL	div16s
    07D0 01C8      MOVW	R24,R16
    07D1 9704      SBIW	R24,4
    07D2 0D82      ADD	R24,R2
    07D3 1D93      ADC	R25,R3
    07D4 011C      MOVW	R2,R24
    07D5 E018      LDI	R17,0x8
    07D6 2F04      MOV	R16,R20
    07D7 940E0917  CALL	mod8u
    07D9 2F10      MOV	R17,R16
    07DA E001      LDI	R16,1
    07DB 940E0971  CALL	lsl8
    07DD 01F1      MOVW	R30,R2
    07DE 8040      LDD	R4,Z+0
    07DF 2A40      OR	R4,R16
    07E0 8240      STD	Z+0,R4
(0270)        }
    07E1 C020      RJMP	0x0802
(0271)        else{
(0272)           CLRBIT(LCD_Buffer[x][y/8-4], y%8);
    07E2 E084      LDI	R24,4
    07E3 9F86      MUL	R24,R22
    07E4 0110      MOVW	R2,R0
    07E5 E782      LDI	R24,0x72
    07E6 E090      LDI	R25,0
    07E7 0E28      ADD	R2,R24
    07E8 1E39      ADC	R3,R25
    07E9 E028      LDI	R18,0x8
    07EA E030      LDI	R19,0
    07EB 2F04      MOV	R16,R20
    07EC 2711      CLR	R17
    07ED 940E08E1  CALL	div16s
    07EF 01C8      MOVW	R24,R16
    07F0 9704      SBIW	R24,4
    07F1 0D82      ADD	R24,R2
    07F2 1D93      ADC	R25,R3
    07F3 011C      MOVW	R2,R24
    07F4 E018      LDI	R17,0x8
    07F5 2F04      MOV	R16,R20
    07F6 940E0917  CALL	mod8u
    07F8 2F10      MOV	R17,R16
    07F9 E001      LDI	R16,1
    07FA 940E0971  CALL	lsl8
    07FC 2E40      MOV	R4,R16
    07FD 9440      COM	R4
    07FE 01F1      MOVW	R30,R2
    07FF 8050      LDD	R5,Z+0
    0800 2054      AND	R5,R4
    0801 8250      STD	Z+0,R5
(0273)        }
(0274) 	 }  
(0275)    } 
    0802 940E093F  CALL	pop_gset2
    0804 9508      RET
_glcd_fillScreen:
  i                    --> R20
  j                    --> R22
  color                --> R16
    0805 940E0951  CALL	push_gset2
(0276) }
(0277) 
(0278) 
(0279) // Purpose:    Fill the LCD screen with the passed in color
(0280) // Inputs:     ON  - turn all the pixels on
(0281) //             OFF - turn all the pixels off
(0282) void glcd_fillScreen(char color)
(0283) {
(0284)    char i,j;
(0285)    if(color==1)
    0807 3001      CPI	R16,1
    0808 F4C1      BNE	0x0821
(0286)    for(i=0;i<GLCD_WIDTH;i++)
    0809 2744      CLR	R20
    080A C013      RJMP	0x081E
(0287)      for(j=0;j<GLCD_HEIGHT/8/2;j++)//  /2
    080B 2766      CLR	R22
    080C C00E      RJMP	0x081B
(0288)        LCD_Buffer[i][j]=0xFF;
    080D E084      LDI	R24,4
    080E 9F84      MUL	R24,R20
    080F 0110      MOVW	R2,R0
    0810 E782      LDI	R24,0x72
    0811 E090      LDI	R25,0
    0812 0E28      ADD	R2,R24
    0813 1E39      ADC	R3,R25
    0814 2FE6      MOV	R30,R22
    0815 27FF      CLR	R31
    0816 0DE2      ADD	R30,R2
    0817 1DF3      ADC	R31,R3
    0818 EF8F      LDI	R24,0xFF
    0819 8380      STD	Z+0,R24
    081A 9563      INC	R22
    081B 3062      CPI	R22,2
    081C F380      BCS	0x080D
    081D 9543      INC	R20
    081E 3840      CPI	R20,0x80
    081F F358      BCS	0x080B
    0820 C017      RJMP	0x0838
(0289)    else
(0290)    for(i=0;i<GLCD_WIDTH/2;i++)
    0821 2744      CLR	R20
    0822 C013      RJMP	0x0836
(0291)      for(j=0;j<4;j++)
    0823 2766      CLR	R22
    0824 C00E      RJMP	0x0833
(0292)        LCD_Buffer[i][j]=0x00;
    0825 E084      LDI	R24,4
    0826 9F84      MUL	R24,R20
    0827 0110      MOVW	R2,R0
    0828 E782      LDI	R24,0x72
    0829 E090      LDI	R25,0
    082A 0E28      ADD	R2,R24
    082B 1E39      ADC	R3,R25
    082C 2FE6      MOV	R30,R22
    082D 27FF      CLR	R31
    082E 0DE2      ADD	R30,R2
    082F 1DF3      ADC	R31,R3
    0830 2422      CLR	R2
    0831 8220      STD	Z+0,R2
    0832 9563      INC	R22
    0833 3064      CPI	R22,4
    0834 F380      BCS	0x0825
    0835 9543      INC	R20
    0836 3440      CPI	R20,0x40
    0837 F358      BCS	0x0823
    0838 940E093F  CALL	pop_gset2
    083A 9508      RET
FILE: E:\avr\iccavrproject\mzl0512864\main.c
(0001) //G1213bin000 12832
(0002) // Target : M16
(0003) // Crystal: 8M
(0004) 
(0005) //description
(0006) 
(0007) #include <iom16v.h>
(0008) #include <macros.h>
(0009) #include "mzl05.h"
(0010) #include "myGRAPHICS.h"
(0011) extern char glcdhalf;
(0012) 
(0013) 
(0014) void port_init(void)
(0015) {
(0016)  	PORTA = 0xFF;
_port_init:
    083B EF8F      LDI	R24,0xFF
    083C BB8B      OUT	0x1B,R24
(0017)  	DDRA  = 0xFF;
    083D BB8A      OUT	0x1A,R24
(0018)  	PORTB = 0xFF;
    083E BB88      OUT	0x18,R24
(0019)  	DDRB  = 0xFF;
    083F BB87      OUT	0x17,R24
(0020)  	PORTC = 0xFF;
    0840 BB85      OUT	0x15,R24
(0021)  	DDRC  = 0xFF;
    0841 BB84      OUT	0x14,R24
(0022)  	PORTD = 0xFF;
    0842 BB82      OUT	0x12,R24
(0023)  	DDRD  = 0xFF;
    0843 BB81      OUT	0x11,R24
    0844 9508      RET
(0024) }
(0025) 
(0026) //call this routine to initialise all peripherals
(0027) void init_devices(void)
(0028) {
(0029)  	//stop errant interrupts until set up
(0030)  	CLI(); //disable all interrupts
_init_devices:
    0845 94F8      BCLR	7
(0031)  	port_init();
    0846 DFF4      RCALL	_port_init
(0032)     
(0033)  	MCUCR = 0x00;
    0847 2422      CLR	R2
    0848 BE25      OUT	0x35,R2
(0034)  	GICR  = 0x00;
    0849 BE2B      OUT	0x3B,R2
(0035)  	TIMSK = 0x00; //timer interrupt sources
    084A BE29      OUT	0x39,R2
(0036)  	SEI(); //re-enable interrupts
    084B 9478      BSET	7
    084C 9508      RET
_main:
    084D 9725      SBIW	R28,5
(0037)  	//all peripherals are now initialised
(0038) }
(0039) 
(0040) 
(0041) void main(void)
(0042) {
(0043)  	init_devices();
    084E DFF6      RCALL	_init_devices
(0044) 	
(0045) 	glcd_init();
    084F 940E06FD  CALL	_glcd_init
(0046) 	glcd_update();
    0851 940E071F  CALL	_glcd_update
(0047)  	//glcd_fillScreen(0x01);
(0048) 	glcdhalf=0;
    0853 2422      CLR	R2
    0854 92200272  STS	glcdhalf,R2
(0049) 	glcd_fillScreen(0);
    0856 2700      CLR	R16
    0857 940E0805  CALL	_glcd_fillScreen
(0050)  	glcd_text35(2,2,"aaaabbbb",1);
    0859 E081      LDI	R24,1
    085A 838A      STD	Y+2,R24
    085B E689      LDI	R24,0x69
    085C E090      LDI	R25,0
    085D 8399      STD	Y+1,R25
    085E 8388      STD	Y+0,R24
    085F E022      LDI	R18,2
    0860 E002      LDI	R16,2
    0861 940E054C  CALL	_glcd_text35
(0051) 	glcd_text35(2,15,"AAAABBBB",1);
    0863 E081      LDI	R24,1
    0864 838A      STD	Y+2,R24
    0865 E680      LDI	R24,0x60
    0866 E090      LDI	R25,0
    0867 8399      STD	Y+1,R25
    0868 8388      STD	Y+0,R24
    0869 E02F      LDI	R18,0xF
    086A E002      LDI	R16,2
    086B 940E054C  CALL	_glcd_text35
(0052) 	glcd_text57(2,30,"AAAABBBB",2,1);
    086D E081      LDI	R24,1
    086E 838C      STD	Y+4,R24
    086F E082      LDI	R24,2
    0870 838A      STD	Y+2,R24
    0871 E680      LDI	R24,0x60
    0872 E090      LDI	R25,0
    0873 8399      STD	Y+1,R25
    0874 8388      STD	Y+0,R24
    0875 E12E      LDI	R18,0x1E
    0876 E002      LDI	R16,2
    0877 940E05E5  CALL	_glcd_text57
(0053) 	glcd_text57(2,45,"aaaabbbb",2,1);
    0879 E081      LDI	R24,1
    087A 838C      STD	Y+4,R24
    087B E082      LDI	R24,2
    087C 838A      STD	Y+2,R24
    087D E689      LDI	R24,0x69
    087E E090      LDI	R25,0
    087F 8399      STD	Y+1,R25
    0880 8388      STD	Y+0,R24
    0881 E22D      LDI	R18,0x2D
    0882 E002      LDI	R16,2
    0883 940E05E5  CALL	_glcd_text57
(0054) 	glcd_line(1,1,64,63,1);
    0885 E081      LDI	R24,1
    0886 838C      STD	Y+4,R24
    0887 E38F      LDI	R24,0x3F
    0888 838A      STD	Y+2,R24
    0889 E480      LDI	R24,0x40
    088A 8388      STD	Y+0,R24
    088B E021      LDI	R18,1
    088C E001      LDI	R16,1
    088D 940E0234  CALL	_glcd_line
(0055) 	glcd_update();
    088F 940E071F  CALL	_glcd_update
(0056) 	glcdhalf=1;
    0891 E081      LDI	R24,1
    0892 93800272  STS	glcdhalf,R24
(0057) 	glcd_fillScreen(0);
    0894 2700      CLR	R16
    0895 940E0805  CALL	_glcd_fillScreen
(0058) 	glcd_text35(2,2,"aaaabbbb",1);
    0897 E081      LDI	R24,1
    0898 838A      STD	Y+2,R24
    0899 E689      LDI	R24,0x69
    089A E090      LDI	R25,0
    089B 8399      STD	Y+1,R25
    089C 8388      STD	Y+0,R24
    089D E022      LDI	R18,2
    089E E002      LDI	R16,2
    089F 940E054C  CALL	_glcd_text35
(0059) 	glcd_text35(2,15,"AAAABBBB",1);
    08A1 E081      LDI	R24,1
    08A2 838A      STD	Y+2,R24
    08A3 E680      LDI	R24,0x60
    08A4 E090      LDI	R25,0
    08A5 8399      STD	Y+1,R25
    08A6 8388      STD	Y+0,R24
    08A7 E02F      LDI	R18,0xF
    08A8 E002      LDI	R16,2
    08A9 940E054C  CALL	_glcd_text35
(0060) 	glcd_text57(2,30,"AAAABBBB",2,1);
    08AB E081      LDI	R24,1
    08AC 838C      STD	Y+4,R24
    08AD E082      LDI	R24,2
    08AE 838A      STD	Y+2,R24
    08AF E680      LDI	R24,0x60
    08B0 E090      LDI	R25,0
    08B1 8399      STD	Y+1,R25
    08B2 8388      STD	Y+0,R24
    08B3 E12E      LDI	R18,0x1E
    08B4 E002      LDI	R16,2
    08B5 940E05E5  CALL	_glcd_text57
(0061) 	glcd_text57(2,45,"aaaabbbb",2,1);
    08B7 E081      LDI	R24,1
    08B8 838C      STD	Y+4,R24
    08B9 E082      LDI	R24,2
    08BA 838A      STD	Y+2,R24
    08BB E689      LDI	R24,0x69
    08BC E090      LDI	R25,0
    08BD 8399      STD	Y+1,R25
    08BE 8388      STD	Y+0,R24
    08BF E22D      LDI	R18,0x2D
    08C0 E002      LDI	R16,2
    08C1 940E05E5  CALL	_glcd_text57
(0062) 	glcd_line(1,1,64,63,1);
    08C3 E081      LDI	R24,1
    08C4 838C      STD	Y+4,R24
    08C5 E38F      LDI	R24,0x3F
    08C6 838A      STD	Y+2,R24
    08C7 E480      LDI	R24,0x40
    08C8 8388      STD	Y+0,R24
    08C9 E021      LDI	R18,1
    08CA E001      LDI	R16,1
    08CB 940E0234  CALL	_glcd_line
(0063) 	glcd_update();
    08CD 940E071F  CALL	_glcd_update
(0064) 	
(0065)  	//insert your functional code here...
(0066)  	while (1)
FILE: <library>
    08CF CFFF      RJMP	0x08CF
    08D0 9625      ADIW	R28,5
    08D1 9508      RET
_abs:
    08D2 FF17      SBRS	R17,7
    08D3 9508      RET
    08D4 9510      COM	R17
    08D5 9501      NEG	R16
    08D6 4F1F      SBCI	R17,0xFF
    08D7 9508      RET
push_arg4:
    08D8 933A      ST	R19,-Y
    08D9 932A      ST	R18,-Y
push_arg2:
    08DA 931A      ST	R17,-Y
    08DB 930A      ST	R16,-Y
    08DC 9508      RET
mod16s:
    08DD 9468      BSET	6
    08DE 92DA      ST	R13,-Y
    08DF 2ED1      MOV	R13,R17
    08E0 C004      RJMP	0x08E5
div16s:
    08E1 94E8      BCLR	6
    08E2 92DA      ST	R13,-Y
    08E3 2ED1      MOV	R13,R17
    08E4 26D3      EOR	R13,R19
    08E5 FF17      SBRS	R17,7
    08E6 C004      RJMP	0x08EB
    08E7 9510      COM	R17
    08E8 9500      COM	R16
    08E9 5F0F      SUBI	R16,0xFF
    08EA 4F1F      SBCI	R17,0xFF
    08EB FF37      SBRS	R19,7
    08EC C004      RJMP	0x08F1
    08ED 9530      COM	R19
    08EE 9520      COM	R18
    08EF 5F2F      SUBI	R18,0xFF
    08F0 4F3F      SBCI	R19,0xFF
    08F1 940E08FE  CALL	xdiv16u
    08F3 FED7      SBRS	R13,7
    08F4 C004      RJMP	0x08F9
    08F5 9510      COM	R17
    08F6 9500      COM	R16
    08F7 5F0F      SUBI	R16,0xFF
    08F8 4F1F      SBCI	R17,0xFF
    08F9 90D9      LD	R13,Y+
    08FA 9508      RET
mod16u:
    08FB 9468      BSET	6
    08FC C001      RJMP	xdiv16u
div16u:
    08FD 94E8      BCLR	6
xdiv16u:
    08FE 92EA      ST	R14,-Y
    08FF 92FA      ST	R15,-Y
    0900 938A      ST	R24,-Y
    0901 24EE      CLR	R14
    0902 24FF      CLR	R15
    0903 E180      LDI	R24,0x10
    0904 0F00      LSL	R16
    0905 1F11      ROL	R17
    0906 1CEE      ROL	R14
    0907 1CFF      ROL	R15
    0908 16E2      CP	R14,R18
    0909 06F3      CPC	R15,R19
    090A F018      BCS	0x090E
    090B 1AE2      SUB	R14,R18
    090C 0AF3      SBC	R15,R19
    090D 9503      INC	R16
    090E 958A      DEC	R24
    090F F7A1      BNE	0x0904
    0910 F416      BRTC	0x0913
    0911 2D0E      MOV	R16,R14
    0912 2D1F      MOV	R17,R15
    0913 9189      LD	R24,Y+
    0914 90F9      LD	R15,Y+
    0915 90E9      LD	R14,Y+
    0916 9508      RET
mod8u:
    0917 9468      BSET	6
    0918 C001      RJMP	xdiv8u
div8u:
    0919 94E8      BCLR	6
xdiv8u:
    091A 932A      ST	R18,-Y
    091B 92FA      ST	R15,-Y
    091C 92EA      ST	R14,-Y
    091D 24FF      CLR	R15
    091E 24EE      CLR	R14
    091F E120      LDI	R18,0x10
    0920 0F00      LSL	R16
    0921 1CFF      ROL	R15
    0922 1CEE      ROL	R14
    0923 16E1      CP	R14,R17
    0924 F010      BCS	0x0927
    0925 1AE1      SUB	R14,R17
    0926 9503      INC	R16
    0927 952A      DEC	R18
    0928 F7B9      BNE	0x0920
    0929 F40E      BRTC	0x092B
    092A 2D0E      MOV	R16,R14
    092B 90E9      LD	R14,Y+
    092C 90F9      LD	R15,Y+
    092D 9129      LD	R18,Y+
    092E 9508      RET
empy16s:
    092F 920A      ST	R0,-Y
    0930 921A      ST	R1,-Y
    0931 938A      ST	R24,-Y
    0932 939A      ST	R25,-Y
    0933 9F02      MUL	R16,R18
    0934 01C0      MOVW	R24,R0
    0935 9F12      MUL	R17,R18
    0936 0D90      ADD	R25,R0
    0937 9F03      MUL	R16,R19
    0938 0D90      ADD	R25,R0
    0939 018C      MOVW	R16,R24
    093A 9199      LD	R25,Y+
    093B 9189      LD	R24,Y+
    093C 9019      LD	R1,Y+
    093D 9009      LD	R0,Y+
    093E 9508      RET
pop_gset2:
    093F E0E2      LDI	R30,2
    0940 940C0957  JMP	pop
pop_gset3:
    0942 E0E4      LDI	R30,4
    0943 940C0957  JMP	pop
pop_gset4:
    0945 E0E8      LDI	R30,0x8
    0946 940C0957  JMP	pop
pop_gset5:
    0948 27EE      CLR	R30
    0949 940C0957  JMP	pop
push_gset5:
    094B 92FA      ST	R15,-Y
    094C 92EA      ST	R14,-Y
push_gset4:
    094D 92DA      ST	R13,-Y
    094E 92CA      ST	R12,-Y
push_gset3:
    094F 92BA      ST	R11,-Y
    0950 92AA      ST	R10,-Y
push_gset2:
    0951 937A      ST	R23,-Y
    0952 936A      ST	R22,-Y
push_gset1:
    0953 935A      ST	R21,-Y
    0954 934A      ST	R20,-Y
    0955 9508      RET
pop_gset1:
    0956 E0E1      LDI	R30,1
pop:
    0957 9149      LD	R20,Y+
    0958 9159      LD	R21,Y+
    0959 FDE0      SBRC	R30,0
    095A 9508      RET
    095B 9169      LD	R22,Y+
    095C 9179      LD	R23,Y+
    095D FDE1      SBRC	R30,1
    095E 9508      RET
    095F 90A9      LD	R10,Y+
    0960 90B9      LD	R11,Y+
    0961 FDE2      SBRC	R30,2
    0962 9508      RET
    0963 90C9      LD	R12,Y+
    0964 90D9      LD	R13,Y+
    0965 FDE3      SBRC	R30,3
    0966 9508      RET
    0967 90E9      LD	R14,Y+
    0968 90F9      LD	R15,Y+
    0969 9508      RET
lsl16:
    096A 2322      TST	R18
    096B F021      BEQ	0x0970
    096C 0F00      LSL	R16
    096D 1F11      ROL	R17
    096E 952A      DEC	R18
    096F CFFA      RJMP	lsl16
    0970 9508      RET
lsl8:
    0971 2311      TST	R17
    0972 F019      BEQ	0x0976
    0973 0F00      LSL	R16
    0974 951A      DEC	R17
    0975 CFFB      RJMP	lsl8
    0976 9508      RET
